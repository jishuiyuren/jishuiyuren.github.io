{"meta":{"title":"吉水于人随笔","subtitle":null,"description":null,"author":"jishuiyuren","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"article13","slug":"article13","date":"2019-03-18T15:29:37.000Z","updated":"2019-03-18T15:29:37.427Z","comments":true,"path":"2019/03/18/article13/","link":"","permalink":"http://yoursite.com/2019/03/18/article13/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"当MVVM遇上AMD","slug":"article12","date":"2019-03-18T15:27:36.000Z","updated":"2019-03-22T08:36:54.876Z","comments":true,"path":"2019/03/18/article12/","link":"","permalink":"http://yoursite.com/2019/03/18/article12/","excerpt":"","text":"MVVM：Model-View-ViewModel，使用MVVM框架实现DOM的更新，并不需要操作DOM，而是直接修改JavaScript对象。AMD：Asynchronous Module Definition，是一种定义模块的方式，且是异步的。","categories":[],"tags":[]},{"title":"我理解的原型链","slug":"article11","date":"2019-03-18T15:23:41.000Z","updated":"2019-03-18T15:28:16.848Z","comments":true,"path":"2019/03/18/article11/","link":"","permalink":"http://yoursite.com/2019/03/18/article11/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"js异步请求总结","slug":"article10","date":"2019-03-18T15:23:37.000Z","updated":"2019-03-18T15:27:30.221Z","comments":true,"path":"2019/03/18/article10/","link":"","permalink":"http://yoursite.com/2019/03/18/article10/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"接口请求方式详解","slug":"article9","date":"2019-03-18T15:23:32.000Z","updated":"2019-03-18T15:25:47.413Z","comments":true,"path":"2019/03/18/article9/","link":"","permalink":"http://yoursite.com/2019/03/18/article9/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"地图导出","slug":"article8","date":"2019-03-18T14:48:34.000Z","updated":"2019-03-18T15:23:17.188Z","comments":true,"path":"2019/03/18/article8/","link":"","permalink":"http://yoursite.com/2019/03/18/article8/","excerpt":"","text":"gis开发侧重于专业知识，相比于其他的前端开发领域，gis功能开发的资料相对较少，我会根据自己的日常项目和学习逐一进行整理，丰富开发资料。由于esri提供的api是用dojo框架开发的，所以在我的博客里涉及到gis开发例子的将是使用dojo语法。今天要给大家介绍一下地图导出模块核心代码。 导出地图需要以下参数：center（地图中心）、scale（导出地图比例尺）、WMTSLayers（WMTS图层）、ArcLayers（arcMap图层）、dpi（像素）、width（地图宽度）、height（地图高度）、extent（当前地图显示范围）、proxyUrl(代理地址)。根据上面的参数，我们需要封装一个ExportMapImg类，包含初始化地图、加载图层、初始化图层导出坐标系、打印几个方法。 初始化地图我们创建一个容器存放当前的地图，并顺利获取地图的空间范围、中心、比例尺等属性。 _initMap: function () { $('body').append($('&lt;div id=\"' + this.mapId + '\" style=\"height:' + this.option.height + 'px;width:' + this.option.width + 'px;z-index:-12;position:absolute;\">&lt;/div>')); this.map = new map(this.mapId, { logo: false, slider: false }); this.map.extent = this.option.extent; var defs = []; if (this.option.center) { defs.push(this.map.centerAt(this.option.center)); } if (this.option.scale) { defs.push(this.map.setScale(this.option.scale)); } all(defs).then(lang.hitch(this,this._addLayers)); } 地图创建好了以后，添加图层。常用的图层服务分为WMTS、dynamic、tiled三种。WMTS是Web地图切片服务,dynamic是动态地图服务，tiled是地图瓦片服务。不同类型的地图服务的加载方法不一样，ersi的开发者文档中有详细的例子可以参照。在我们这个例子中，添加图层是用于map的初始化，所以WMTS图层全部添加，而arcgis图层则只添加一个图层。 _addLayers: function () { var defs = []; if (this.option.WMTSLayers.length) {//保证行列号完全正确，所有wmts图层都添加 defs = this.option.WMTSLayers.map(function (item) { var def = new Deferred(); item.on('update-end', function () { def.resolve(); }); this.map.addLayer(item); return def; }, this); } if (!this.option.WMTSLayers.length &amp;&amp; this.option.ArcLayers.length) {//当未添加wmts图层时，只添加一个图层用于map初始化 var def = new Deferred(); var layerItem = this.option.ArcLayers[0]; var layer = new ArcGISDynamicMapServiceLayer(layerItem.url); layer.setVisibleLayers(layerItem.visibleLayers); layer.on('load', function () { def.resolve(); }); this.map.addLayer(layer); defs.push(def); } if (this.option.graphics.length) { var graLayer = new GraphicsLayer(); this.map.addLayer(graLayer); this.option.graphics.map(function (gra) { if (!gra.symbol) { gra.setSymbol(this._getSymbol(gra.geometry.type)); } graLayer.add(new Graphic(gra.geometry, gra.symbol)); }, this); } all(defs).then(lang.hitch(this, this._print)); }, 地图导出相对来说比较复杂，因为要将地图服务生成图片，这里我选择的是将arcgis图层使用export接口输出为png图片，并转为base64；将WMTS图层的瓦片转为base64。 /** *ArcGis 图层全部使用export接口输出png图片，并转换为base64 * @returns {Deferred} * @private */ _getExportPngs: function () { var pngsDef = new Deferred(); var $pngRoot = $('&lt;div style=\"width: 100%;height: 100%;position: absolute;\">&lt;/div>'); var defs = this.option.ArcLayers.map(function (item) { return this._exportPng(item.url, this.map.extent, this.option.dpi, this.option.height, this.option.width, item.visibleLayers, this.option.innerSR, this.option.outSR); }, this); all(defs).then(lang.hitch(this, function (results) { results.map(function (img) { $pngRoot.append($('&lt;img alt=\"\" style=\"width: 100%;height: 100%;position: inherit;\" src=\"' + img + '\">')); }); pngsDef.resolve($pngRoot); })); return pngsDef; }, /** * 将wmts图层的瓦片转为base64,并返回瓦片位置变换后的div节点 * @returns {Deferred} * @private */ _getTileLayerImgs: function () { var layersDef = new Deferred(); var scale = this.map.getScale(); var rect = this.map.__visibleRect; var $layersRoot = $('&lt;div>&lt;/div>'); var layerTileStr = 'position:absolute;border:none;margin:0;padding:0;visibility:inherit;'; var layerDivStr = 'position:absolute;overflow:visible;transition:-webkit-transform 500ms ease 0s;'; var tileLayersStr = 'position:absolute;overflow:visible;display:block;'; var layerDefs = []; this.option.WMTSLayers.map(function (item) {//图层 var layer = this.map._layers[item.id]; if (scale &lt; layer.maxScale &amp;&amp; scale > layer.minScale) return; var layerDef = new Deferred(); var $root = $('&lt;div style=\"height: ' + rect.height + 'px;width: ' + rect.width + 'px;' + 'transform: translate(' + layer.__coords_dx + 'px,' + layer.__coords_dy + 'px);' + tileLayersStr + '\">&lt;/div>'); var $layer = $('&lt;div style=\"height: ' + rect.height + 'px;width: ' + rect.width + 'px;' + layerDivStr + '\">&lt;/div>'); var tiles = layer._tileIds; var tileBs = layer._tileBounds; var tileImgs = layer._tiles; var defs = tiles.map(function (id) {//瓦片 var tileItem = tileBs[id]; var def = new Deferred(); var imgSrc = (this.option.proxyUrl === '' ? '' : this.option.proxyUrl + '?') + tileImgs[id].src; // console.log(imgSrc); this._getImgBase64(imgSrc, 'png', tileItem.height, tileItem.width).then( lang.hitch(this, function (url) { $layer.append($('&lt;img style=\"height: ' + tileItem.height + 'px;width: ' + tileItem.width + 'px;' + 'transform: translate(' + tileItem.x + 'px,' + tileItem.y + 'px);' + layerTileStr + '\" src=\"' + url + '\">')); def.resolve(); }) ); return def; }, this); $root.append($layer); all(defs).then(lang.hitch(this, function () { layerDef.resolve($root); })); layerDefs.push(layerDef); }, this); all(layerDefs).then(lang.hitch(this, function ($layers) { $layersRoot.append($layers); layersDef.resolve($layersRoot); })); return layersDef; }","categories":[],"tags":[]},{"title":"关于微信登录","slug":"article7","date":"2019-03-17T13:52:59.000Z","updated":"2019-03-17T14:24:05.851Z","comments":true,"path":"2019/03/17/article7/","link":"","permalink":"http://yoursite.com/2019/03/17/article7/","excerpt":"","text":"做微信小程序也有小一个月了，整体来说，做的比较顺利，没有遇到特别难搞的坑，这里还是得感谢腾讯为开发者提供资料齐全的开发文档。想速度上手微信小程序的小伙伴们，戳这里，微信小程序开发者文档 微信小程序开发中，我们常常需要获取用户信息，我写小程序时是1月份，开始我并不知道接口已经做了调整，然后就直接使用button去获取用户信息，然而，调试时，出现以下提示。当我去官方文档上查阅获取用户信息接口时，发现其已经做了一些的调整。相信大家都知道，我们在第一次使用某个小程序时会弹出一个授权框，询问用户是否允许获取用户信息。如今接口调整为在用户未授权过的情况下调用此接口，将不再出现授权弹窗，会直接进入 fail 回调。在用户已授权的情况下调用此接口，可成功获取用户信息。 竟然不再出现授权窗口了，那我们就需要使用button进行引导。 &lt;button class='wexin-login' open-type=\"getUserInfo\" lang=\"zh_CN\" bindgetuserinfo=\"onGotUserInfo\"> &lt;image class='wexin-icon' src='/assets/images/content/share_wechat.png' /> &lt;text class='wexin-text' open-type=\"getUserInfo\" bindgetuserinfo=\"onGotUserInfo\" lang=\"zh_CN\">微信登录&lt;/text> &lt;/button> 逻辑部分处理为: getWXCode: function() { var that = this; wx.login({ success: function(res) { api.post('/edu/user/WechatAPPLogin', { encryptedData: that.data.userInfo.encryptedData, iv: that.data.userInfo.iv, code: res.code }, function(res) { that.onBack() getApp().globalData.userId = res.content.userInfo.id }.bind(this), function(res) { wx.showToast({ title: res.msg, icon: 'none', duration: 2000 }) }) } }) }","categories":[],"tags":[]},{"title":"制作一个添加工作经验的功能","slug":"article6","date":"2019-03-17T04:30:58.000Z","updated":"2019-03-17T13:49:44.520Z","comments":true,"path":"2019/03/17/article6/","link":"","permalink":"http://yoursite.com/2019/03/17/article6/","excerpt":"","text":"前几天给一个app做项目经验添加功能时，自己犯了几个错误，于是决定总结一下，算是写成一个demo，给大家参考一下吧。 添加工作经验的页面如图1，这是一个用户的详情页面，每条工作经验的右上角，添加了删除按钮，区域的下方有继续添加经历的按钮。说白了，这个功能就是实现对表单数据的增、删、改功能。首先，我从后端接口中获取到用户的工作经验数据（也可能是一个空数组），这块的逻辑我们很容易写出来，就是根据获取到的值进行遍历即可。 &lt;div v-for=\"(item, index) in experiences\" :key=\"item.id\"> &lt;div class=\"detail\"> &lt;image class=\"closeIcon\" :src=\"iconPath('icon_gb_small')\" @click=\"removeExperience(item.id)\">&lt;/image> &lt;text class=\"unselect-txt\">开始时间&lt;/text> &lt;input class=\"input\" type=\"date\" v-model=\"item.startDate\">&lt;/input> &lt;image class=\"icon\" :src=\"iconPath('icon_pen')\">&lt;/image> &lt;/div> &lt;div class=\"detail\"> &lt;text class=\"unselect-txt\">结束时间&lt;/text> &lt;input class=\"input\" type=\"date\" v-model=\"item.endDate\">&lt;/input> &lt;image class=\"icon\" :src=\"iconPath('icon_pen')\">&lt;/image> &lt;/div> &lt;div class=\"detail2\"> &lt;text class=\"unselect-txt\">从业说明：&lt;/text> &lt;textarea v-model=\"item.introduction\" class=\"textarea\">&lt;/textarea> &lt;/div> &lt;div class=\"list-gap\">&lt;/div> &lt;/div> &lt;div> &lt;div class=\"next-btn\" @click=\"addNextExperience\"> &lt;text class=\"next-button\">继续添加经历&lt;/text> &lt;/div> &lt;/div> &lt;div class=\"btn\" @click=\"addUserMaterial\"> &lt;text style=\"font-size: 28px;color: #ffffff;\">完成&lt;/text> &lt;/div> 我们在input和textarea中使用v-model进行数据的双向绑定。我们都知道，vue实现了一套虚拟的DOM，我们不需要直接操作DOM元素，只需要操作数据就可重新渲染页面。而背后的原理得益于高效的Diff算法，具体的原理我不在这阐述。key的作用是为了高效的更新虚拟DOM。所以为了让vue可以区分他们，我们在做循环或相同标签元素的过渡切换时，都有必要使用到key属性，所以在上述循环中我们指定项目经验的id为key值。下面我们开始写新增事件和删除事件。新增 addNextExperience() { this.experienceId++ this.experiences.push({id: this.experienceId, startDate: '', endDate: '', introduction: ''}) } 删除 removeExperience(index) { this.experiences = this.experiences.filter(function (experience) { return (index !== experience.id); }) } 新增事件我使用了一个全局变量experienceId为id赋值，这个experienceId的值为多少合适呢。我们上面通过接口拿到了当前用户的工作经验值，每条工作经验都有一个id号，我首先想到的就是，在我新增时，这个id号的起始值应该为当前用户的工作经验的id号的最大值+1，这样做的原因是为了保证从后端接口取出的id号和我任意一条新增数据的id号都不会相同，这样一来，每一条工作经验的id号才不会出现重复的情况。","categories":[],"tags":[]},{"title":"ES6常用总结","slug":"article5","date":"2019-03-16T14:30:30.000Z","updated":"2019-03-19T11:17:57.415Z","comments":true,"path":"2019/03/16/article5/","link":"","permalink":"http://yoursite.com/2019/03/16/article5/","excerpt":"","text":"文章参考来源:[ECMAScript 6 入门]","categories":[],"tags":[]},{"title":"正则表达式化整为零","slug":"article4","date":"2019-03-15T07:53:53.000Z","updated":"2019-03-19T09:13:28.011Z","comments":true,"path":"2019/03/15/article4/","link":"","permalink":"http://yoursite.com/2019/03/15/article4/","excerpt":"","text":"写代码也有一段时间了，正则表达式是经常会用得到，每次遇到一些匹配时，就上网找，因为自己一直都在排斥学正则表达式，但是拖着不是程序猿的好习惯，那今天就来好好整理下。不求全部学会，只求见到认识。正则表达式常用的几种操作方法有：match、search、split、findall、sub、replace。 基本字符特殊字符特殊字符就是具有特殊含义的字符。在正则表达式中，这些特殊字符匹配的意义各有不同，如果需要在字符串中查找这些特殊符号，就需要在其前面加一个\\进行转义。 特殊字符 含义 $ 匹配输入字符串的结尾 （） 标记一个子表达的开始和结束位置 * 匹配前面的表达式零次或多次 + 匹配前面的子表达式一次或多次 . 匹配除换行符\\n 之外的任何单字符 [ 标记一个中括号表达式的开始 ？ 匹配前面的子表达式零次或一次 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合 { 标记限定符表达式的开始 指明两项之间的一个选择 贪婪和非贪婪 在上表中列举的*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 定位符定位符用来描述字符串或单词的边界，其中^和$分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B表示非单词边界。 Tip：不能将限定符和定位符一起使用。 带反斜杠的元字符普通字符前加反斜杠还是普通字符，但是有些字符加上反斜杠之后就会变成元字符 语法1.检索字符我们既可以检索普通字符也可以检索表情符号，因为表情符其实也是一个字符，使用match方法可以返回一个数组，包含检索字符内容，被检索到到索引号。 'hello world'.match(/w/); > [\"w\", index: 6, input: \"hello world\", groups: undefined] 'hello 😀world'.match(/😀/); > [\"😀\", index: 6, input: \"hello 😀world\", groups: undefined] 2.匹配文本开始和结束我们用^匹配文本的开始，用$匹配文本的结束。匹配文本的第一个字符时，必须是匹配文本的第一个字符，否则匹配不成功。 'hello'.match(/^h/); > [\"h\", index: 0, input: \"hello\", groups: undefined] 'hello'.match(/a^h/); > null 'hello'.match(/o$/); > [\"o\", index: 4, input: \"hello\", groups: undefined] 3.元字符 元字符 含义 \\b 匹配一个单词边界 \\B 匹配一个非单词边界 \\d 匹配一个数字字符 \\D 匹配一个非数字字符 \\s 匹配一个空白字符 \\S 匹配一个非空白字符 \\w 匹配一个字母或一个数字或一个下划线 \\W 匹配一个字母、数字和下划线之外的字符 元字符上述表格中已列举出来了，元字符的大写相当于取反。匹配单词边界的对中文边界是无效的。 // \\b 匹配单词边界 'hello world'.match(/\\bworld$/); > [\"world\", index: 6, input: \"hello world\", groups: undefined] '你 好'.match(/\\B好$/); [\"好\", index: 2, input: \"你 好\", groups: undefined] // \\d 匹配数字边界 '123'.match(/\\d2/); [\"12\", index: 0, input: \"123\", groups: undefined] // \\s匹配单个空白字符 'a b'.match(/\\s/); [\" \", index: 1, input: \"a b\", groups: undefined] // \\w匹配单个字母数字下划线 'a b'.match(/\\w/); [\"a\", index: 0, input: \"a b\", groups: undefined] 4.量词限定符用来指定正则表达式的一个给定组件必须要出现多次才能匹配 字符 描述 * 匹配前面的子表达式零次或多次 + 匹配前面的子表达式一次或多次 ？ 匹配前面的子表达式零次或一次 {n} n是一个非负整数。匹配确定的n次 {n,} 至少匹配n次 {n,m} n&lt;=m，最少匹配n次最多匹配m次 // 非贪婪模式 'https'.match(/http(s)?/); [\"https\", \"s\", index: 0, input: \"https\", groups: undefined] 'gooooogle'.match(/go{2,5}gle/); [\"gooooogle\", index: 0, input: \"gooooogle\", groups: undefined] 5.字符组方括号在正则中表示一个区间,我们称之为字符组。 'grey or gray'.match(/gr[ae]y/); [\"grey\", index: 0, input: \"grey or gray\", groups: undefined] 6.捕获组和非捕获组[ES2018]圆括号的意思是将它其中的字符集合打包成一个整体,然后量词就可以操作这个整体了。 'i love you very very very much'.match(/i love you (very )+much/); [\"i love you very very very much\", \"very \", index: 0, input: \"i love you very very very much\", groups: undefined] 7.正则内捕获正则内捕获使用\\数字的形式根据对应前面的圆括号捕获内容，这种捕获的引用也称为反向引用。 '&lt;span>hello world&lt;/span>'.match(/&lt;([a-zA-Z]+)>.*&lt;\\/\\1>/); > [\"&lt;span>hello world&lt;/span>\", \"span\", index: 0, input: \"&lt;span>hello world&lt;/span>\", groups: undefined] 8.正则外捕获 'hello **world**'.replace(/\\*{2}(.*)\\*{2}/, '&lt;strong>$1&lt;/strong>'); \"hello &lt;strong>world&lt;/strong>\" 9.非捕获组当我们需要匹配捕获组,但是又不需要捕获组结果时,我们可以使用非捕获组(?:pattern) 'industry'.match(/industr(?:y|ies)/); [\"industry\", index: 0, input: \"industry\", groups: undefined] 10.或 'aA'.match(/a|A/); [\"a\", index: 0, input: \"aA\", groups: undefined] 11.零宽断言零宽断言零宽：匹配一个位置，本身没有宽度；断言：断言之前或者之后应该有什么或没有什么（1）零宽肯定先行断言(?=)[正向肯定预查] 'TypeScript JavaScript javascript'.match(/\\b\\w{4}(?=Script\\b)/); [\"Type\", index: 0, input: \"TypeScript JavaScript javascript\", groups: undefined] （2）零宽肯定后行断言(?&lt;=)[ES2018] [反向肯定预查] '演员高圆圆 将军霍去病 演员霍思燕'.match(/(?&lt;=演员)霍\\S+/); [\"霍思燕\", index: 14, input: \"演员高圆圆 将军霍去病 演员霍思燕\", groups: undefined] （3）零宽否定先行断言(?!)[正向否定预查]否定就是没有,就是要求一段文本,后面一定不要紧跟一段指定文本 'TypeScript Perl JavaScript'.match(/\\b\\w{4}(?!Script\\b)/); [\"Perl\", index: 11, input: \"TypeScript Perl JavaScript\", groups: undefined] （4）零宽否定后行断言(?&lt;!)[ES2018] [反向否定预查]要求一段文本,前面一定不跟某一段指定文本 '演员高圆圆 将军霍去病 演员霍思燕'.match(/(?&lt;!演员)霍\\S+/); [\"霍去病\", index: 8, input: \"演员高圆圆 将军霍去病 演员霍思燕\", groups: undefined] 12.修饰符（1）g修饰符(global) 默认情况下,正则从左向右匹配,只要匹配到结果就会结束,g修饰符会开启全局匹配模式,找到所有的匹配结果（2）i修饰符(ignoreCase)默认情况话,正则是区分大小写的,i修饰符的作用是可以全局忽略大小写.（3）m修饰符(multiline)默认情况下，^和$匹配的是文本的开始和结束，加上m修饰符，它们的含义就变成了多行的行首和行尾,支持多行搜索（4）y修饰符(sticky粘连)[ES6]y修饰符有和g修饰符重合的功能，它们都是全局匹配,不同在于,g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义 'a bag with a tag has a mag'.match(/\\wag/g); [\"bag\", \"tag\", \"mag\"] 'a bag with a tag has a mag'.match(/\\wag/y); null 'bagtagmag'.match(/\\wag/y); [\"bag\", index: 0, input: \"bagtagmag\", groups: undefined] 'bagtagmag'.match(/\\wag/gy); [\"bag\", \"tag\", \"mag\"] （5）s修饰符(singleline)[ES2018]s修饰符的作用是让.可以匹配任意单个字符。（6）u修饰符(unicode)[ES6]有些Unicode字符超过一个字节,正则无法正确识别,可用u修饰符来处理。 ES6变化ES6中,将字符串的4个正则方法(match,replace,search,split)在语言内部全部调用RegExp的实例方法,从而做到所有与正则相关的方法,全部定义在RegExp对象上。","categories":[],"tags":[]},{"title":"JavaScript内存优化","slug":"article3","date":"2019-03-15T06:33:19.000Z","updated":"2019-03-15T07:50:13.484Z","comments":true,"path":"2019/03/15/article3/","link":"","permalink":"http://yoursite.com/2019/03/15/article3/","excerpt":"","text":"##内存泄漏当程序持续无法释放其使用的临时内存时就会发生内存泄漏。JavaScript提供GC垃圾回收进行自动内存管理，其机制是找出不再使用的变量，释放其占用的内存，但是这个内存不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 不再使用的变量就是生命周期结束的变量，即局部变量（全局变量的生命周期直到浏览器卸载才会结束）。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束。闭包中由于内部函数的原因，外部函数并不能算是结束。 ##避免内存泄漏(1)避免DOM节点创建中闪屏IE中有一类典型的内存泄漏模式称为DOM插入顺序内存泄漏。当创建动态当DOM节点时，我们确保上层元素首先被附着，然后是底层。如果顺序反过来，可能导致内存泄漏。当要创建的 DOM 树很大时，这种从上而下的创建 DOM 节点的方式可能会造成浏览器视图的闪烁。一个好的办法是在 DOM 树渲染期间通过样式”display:none”把最顶层父节点隐藏起来，直到整个 DOM 树都创建好之后，再把顶层父节点展现出来。 var frameNode = domCon.create('div', { \"style\": {display: \"none\"} }, this.domNode); // 创建 frameNode 节点下的子节点树 // 当子节点树创建好之后，显示整个 frameNode 节点树 domStyle.set(frameNode, \"display\",'block') (2)DOM节点循环引用当Javascript对象引用DOM元素并且DOM元素当属性引用Javascript对象时，循环应用发生并导致DOM节点泄漏。 var obj = document.getElementById(\"id\"); document.getElementById(\"id\").expandoProperty = obj; 若需要这么使用，在准备移除节点时，先将元素expandoProperty属性设置为null。 (3)Dom节点的引用 &lt;html> &lt;body> &lt;div id=\"refA\"> &lt;ul> &lt;li>&lt;a>&lt;/a>&lt;/li> &lt;li>&lt;a>&lt;/a>&lt;/li> &lt;li>&lt;a id=\"refB\">&lt;/a>&lt;/li> &lt;/ul> &lt;/div> &lt;/body> &lt;/html> &lt;script> var refA = document.getElementById('refA'); var refB = document.getElementById('refB'); refB=null; refB引用了refA。它们之间是dom树父节点和子节点的关系。如果在此时移除refA,或者将refA对象设置为null，那么这个dom节点在浏览器内存中依然存在。因为refB对refA存在引用，所以除非在把refB释放，否则dom节点内存会一直存在浏览器中无法被回收掉。(4)闭包 window.onload = function() { var obj = document.getElementById(\"element\"); // this creates a closure over \"element\" // and will leak if not handled properly. obj.onclick = function(evt) { alert(\"leak the element DIV\"); }; }; 应用程序之后删除了element节点，JavaScript 引用仍然会持有孤立节点。这个孤立节点将会造成内存泄露。(5)定时器setTimeout setInterval当不需要setInterval或者setTimeout时，定时器没有被clear，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏。 ##ChromeDevTools工具 以上介绍了几种内存泄漏的情况，那么我们在项目中如何发现可能存在内存泄漏的地方。 PerformancePerformance按时间顺序展示页面加载过程及后续过程的网络请求、页面渲染过程、JS运行时长、页面帧率、CPU/GPU使用情况等1，在timeline中观测页面资源加载情况（时长，顺序），降低页面加载时长。2，在timeline中观测FPS情况，观测底下的JS执行耗时，能分析出哪部分耗时过长，导致帧率下降 Memory Memory监控CPU使用情况，内存分配情况等，用于做深入分析 1、Record Allocation profiles(allocation sampling)监控函数执行期花费的时间。点击下方的Start按钮（也可以点击左边的黑色圆圈），这时候Chrome会开始记录网页的方法执行，然后我们点击界面的按钮来执行。（用来查看分配给各函数的内存大小）最后再点击右边区域的Stop按钮（或者左边的红色圆圈），这时监控就结束了。左边Profiles会列出一个文件，单击可以看到如下界面从上面结果中，可以发现，在点击开始，运行操作界面之后，点击停止，该工具记录了在这个期间，执行过的一些函数，以及执行这些函数所分配的内存状况。可以转换chart图表模式查看。2、Record Allocation timeline它的作用是为我们拍下一系列的快照（频率为50ms），为我们检测在启用它的时候每个对象的生存情况。形象一点说就是假如拍摄内存快照的功能是照相那么它功能相当于录像。当启用start按钮的时候它便开始录像，直到结束。左侧区域上半部分有一些蓝色和灰色的柱条。灰色的表示监控这段时间内活跃过的对象，但是被回收掉了。蓝色的表示依旧没有没回收.（用来查看实时的内存分配及回收情况）。3、Heap snapshotSummary(概要)视图能帮你通过构造函数分组寻找对象(和对象的内存使用)。该视图对找出DOM内存泄漏很有帮助。Comparison(对照)视图能够通过显示哪些对象内存被正确的回收了来搜寻内存泄漏。通常在一个操作前后记录两个(或更多)的内存使用快照。它是通过察看释放的内存和引用数目的差导来察看是否有内存泄漏，并找到原因。Constructor(构造函数)表示所有通过该构造函数生成的对象 Distance 对象到达GC根的最短距离 Shallow size 对应构造函数生成的对象的shallow sizes(直接占用内存) Retained size 展示了对应对象所占用的最大内存。 function a() { var obj = [1,2,.......n]; return function() { //js作用域的原因，在此闭包运行的上下文中可以访问到obj这个对象 console.log(obj); } } var b = a(); ######正常情况下，a函数执行完毕 obj占用的内存会被回收，但是此处a函数返回了一个函数表达式，其中obj因为js的作用域的特殊性一直存在，所以我们可以说b引用了obj。每次访问b对象的时候都可以访问到obj，说明内存未被回收 所以对于obj来说直接占用内存[1,2,….n], 而b依赖obj，所obj是b的最大内存。","categories":[],"tags":[{"name":"内存优化","slug":"内存优化","permalink":"http://yoursite.com/tags/内存优化/"}]},{"title":"地图出图/打印","slug":"article","date":"2019-03-15T06:28:12.690Z","updated":"2019-03-15T06:28:12.690Z","comments":true,"path":"2019/03/15/article/","link":"","permalink":"http://yoursite.com/2019/03/15/article/","excerpt":"","text":"地图打印输出作为webgis较为常用的一个模块，由于其实现过程和参数较为复杂，对其功能的调整和扩展，通常是前端开发中一个较为头疼的事情 。本文将结合项目经验介绍前端实现地图导出三个主要途径的实现过程及注意事项。功能有限，内容不全面，如有错误和不足请指出。 实现方式纯前端支持wmts服务（1）、arcgis服务（2）和GraphicLayer（3）三种类型组合导出图片。当系统中接入wmts服务时，ArcgisServer自带的打印服务和前端截图插件不能满足需求（截图wmts图层为空白），具体原因就未做深入；刚好项目碰到这个问题，好几个重要功能都受到影响,因此有了这个解决方案 wmts服务添加到map后arcgisapi会根据当前视图计算用于显示瓦片，并通过二维变换让所有图片拼接显示。这些变换的参数在图层对象中都能获取到，根据这些变换参数可以将瓦片手动拼成‘一张图片’。功能主要解决的问题还是资源跨域问题，瓦片要转换为base64编码的图片，然后拼合成一张图片，最后在使用前端截图插件dom-to-image或html2canvas进行图片生成。 1.初始化map对象，div显示层级为负，设置map的中心点和比例尺2.添加底图和要素图形(1)有wmts:为保证wmts服务的瓦片获取正确无误，必须全部添加到map上，监听每个服务的update-end事件，不添加arcgis服务(2)无wmts:arcgis服务只需添加一个即可，我们只是需要map初始化完成后的extent，监听服务的load事件3.待上述事件全部抛出，开始打印准备，创建打印根节点元素(层级设为负) (1)wmts服务瓦片获取并转为base64，拼合做位置变换，完成后返回服务图片容器的元素节点 (2)arcgis服务export图片，dpi、bbox、height、width、sr、visibleLayers，每个服务都要进行请求，都完成后返回服务图片容器的元素节点（因为gp服务导出的图片不透明，所以每个服务都要请求）4、将3中返回的元素加入打印根结点元素，克隆map中要素图层的svg元素，加入打印根节点元素5、使用截图插件出图，让完成事件抛出 var exportImg = new ExportMapImg({ center: this.map.extent.getCenter(), scale: this.map.getScale(), WMTSLayers: [new WMTS(url,...),new WMTS(url,...)], ArcLayers: [{url:'http://192.168.200.113:6080/arcgis/rest/services/CDYZT/CHDZTGH/MapServer',visibleLayers:[101]}], dpi: this.dpi, width: width, height: height }); on.once(exportImg, 'export-success', function (url) { exportImg.downLoad(url); exportImg = null; }); IE支持GraphicLayer导出html2canvas在ie中使用不支持svg的输出；将svg输出为Blob地址和svgbase64地址赋给img，然后绘制在canvas会出现跨域而污染画布不能使用toBlob()、toDataURL()、getImageData()；IE报‘SCRIPT5022: SecurityError’错误：网上说的是跨域原因，解决方案有3个：img. crossOrigin设置 、插件和ajax从后台获取1.插件：canvg.js，以及canvg的依赖rgbcolor.js、stackblur-canvas.js，在plugins目录下，请在项目中引用，本人的引入位置：成功(只需要引入插件依赖即可，处理部分已经封装)2.后台（一个传入什么返回什么的接口）：失败(SCRIPT5022: SecurityError)从使用了后台测试后基本排除了跨域的原因，因为直接使用base64Png图片不设置图片跨域绘制到canvas里，canvas的像素操作不受影响，这也就说明问题可能出在IE的canvas对象对svg图片的支持上所以目前不考虑后台转化支持的话，前端只能通过canvg.js将svg绘制在canvas里（个人见解，如果大家有更好的方式请务必告知一下） DPI相关内容dpi=96:每英寸点数1in=2.54cm一般情况下，提高export接口导出图片的精度，如下图：（地址）单纯提高dpi。从结果来看范围是一致了，但是出图的比例尺变化了将dpi和尺寸乘以相同倍数，如下图：导出范围一致，比例尺一致举例：假如需要打印一张照片2inX2in（dpi=100）这时像素尺寸应为200pxX200px 假如还需要打印一张照片2inX2in (dpi=300) 这时像素尺寸应为600pxX600px当只有像素尺寸200pxX200px图片，打印一张2inX2in的照片dpi=300，打印机会进行栅格化处理，将（200px→600px）X (200px→600px)输出打印，这种情况下打印的照片应该会出现平时所说的马赛克以上内容个人见解，正确性未知；为什么要讲这个内容？因为wmts服务切片一般都是默认的dpi=96，所以想要输出更高精度的图片，也就和上面例子中一样，要将切片栅格化放大处理后，在输出，结果就是严重失真因此对更高dpi未做支持，初始化参数中有这个内容，那只有arcgis服务export接口会使用到，传高了服务返回还会变慢，所以默认96； GP 服务GP服务图片导出：一张图和多规基线用的就是这个方式，但是很多项目都接入的wmts服务，导出的图片没有wmts图层的内容，也就有了前面的前端解决方案为了对照，我们还是说一下GP服务的使用：（地址）打印模板可配置的内容还有很多详见(api) //创建地图打印对象 var printMap = new PrintTask(this.config.serviceUrl); //创建地图打印模版 var template = new PrintTemplate(); //创建地图的打印参数，参数里面包括：模版和地图 var params = new PrintParameters(); //输出图片的空间参考 printMap.outSpatialReference = this.map.spatialReference; //打印图片的各种参数 template.exportOptions = { width: this.map.width, height: this.map.height, dpi: 96 }; //打印输出的格式 template.format = 'JPG'; //输出地图的布局 template.layout = 'MAP_ONLY'; // PrintTemplate //设置参数地图 params.map = this.map; //设置参数模版 params.template = template; //运行结果 printMap.execute(params, lang.hitch(this, function (result) { if (result) { console.log(result); } }), lang.hitch(this, function (error) { console.log(error); })); }","categories":[],"tags":[]},{"title":"多坐标系下地图面积测量","slug":"article2","date":"2019-03-13T14:40:01.000Z","updated":"2019-03-13T14:48:37.866Z","comments":true,"path":"2019/03/13/article2/","link":"","permalink":"http://yoursite.com/2019/03/13/article2/","excerpt":"","text":"function calArea(polygon, spatialReference) { if (spatialReference.isWebMercator() || spatialReference.wkid == \"4326\" || spatialReference.wkid == \"4490\") { return geometryEngine.geodesicArea(polygon, \"square-meters\") } else if (spatialReference.wkid == \"4610\") { return geodesicUtils.geodesicAreas([polygon], esriUnits.SQUARE_METERS)[0]; } else { return geometryEngine.planarArea(polygon, \"square-meters\") } }","categories":[],"tags":[]}]}