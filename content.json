{"pages":[],"posts":[{"title":"视频播放进度记录","text":"前言微信小程序提供一个video组件支持视频播放，开发者文档上可以看到，该组件提供了很多可选属性，具体的可查阅微信小程序开发文档。 具体实现为了有效记录视频的播放进度，我准备在视频播放过程中每十秒一周期、视频暂停时、视频播放结束时上报一次当前时间。使用initial-time让视频从当前时间开始进行播放。 &lt;video class=\"video\" autoplay=\"true\" src=\"{{url}}\" controls bindtimeupdate='bindtimeupdate' bindpause='bindpause' bindended='bindended' controls initial-time=\"{{currentTime}}\">&lt;/video> bindtimeupdate事件可以直接获取到播放视频的当前时间和总时长。每隔十秒去请求一次接口，将时间存储下来。 bindtimeupdate(res) { this.data.currentTime = parseInt(res.detail.currentTime) // 当前时间 this.data.duration = parseInt(res.detail.duration) // 总时长 if (this.data.flag) return this.data.flag = setInterval(this.getPlayTime, 10000); // 十秒上报一次 } 暂停时记录一次当前时间，并清除setInterval事件，防止持续上报。bindended与bindpause事件逻辑一致。 bindpause(e) { if (this.data.currentTime !== this.data.duration) { this.data.isEnd = false } this.getPlayTime() if (this.data.flag) { clearInterval(this.data.flag) this.data.flag = null } } 实现效果在我的学习页面，可以看到每个视频的已播放进度条。进入视频，视频从当前视频时间继续播放。","path":"2019/04/02/article15/"},{"title":"微信小程序的上拉加载功能","text":"前言这段时间一直在弄智荟那个微信小程序，发现，很多地方的列表加载都需要用到上拉加载更多这个功能，一开始，看了官方文档觉得蛮简单的，但是在实际写的过程中还是踩了一点的坑，所以就在这做一个简单的总结。 前端页面在前端页面中，我们使用scroll-view组件去实现这个上拉加载的功能。用bindscrolltolower去触发加载更多事件。 &lt;scroll-view bindscrolltolower=\"loadMore\" scroll-y=\"true\" class='scroll-content' style=\"height:{{scrollHeight}}px;\"> &lt;view wx:for='{{results}}' wx:key='{{index}}' bindtap='onDetail' data-item='{{item}}'> &lt;view class='search-items'> &lt;view class='content-detail'> &lt;image class='search-img' resize=\"cover\" src='{{item.image}}' /> &lt;view class='search-content'> &lt;text class='search-title'>{{item.name}}&lt;/text> &lt;view class='cell-gap'>&lt;/view> &lt;text class='search-type'>{{type[item.type-1]}}&lt;/text> &lt;/view> &lt;/view> &lt;/view> &lt;/view> &lt;loading-cell status=\"{{loadingStatus}}\">&lt;/loading-cell> &lt;/scroll-view> 在scroll-view中我动态的改变了其高度，而初始该高度的获取，我使用了微信提供的getSystemInfo来获取。其实，一开始我踩了一个坑，就是这里并没有去这样拿高度，而是根据页面的情况，自己写死了一个高度，以至于一直没有实现效果。 onLoad: function(options) { var that = this; wx.getSystemInfo({ success: function(res) { that.setData({ scrollHeight: res.windowHeight }); } }); } 我申明了三个变量：pageNo（页码）、pageCount（总页数）、scrollHeight（滚动高度）。 data: { pageNo: 1, pageCount: 0, scrollHeight: 0 }, loadMore监听页数的变化，当前页码小于总页数时，请求接口，获取结果。 loadMore(e) { if (this.data.pageNo &lt; this.data.pageCount) { this.data.pageNo++ this.getSearchResults() } } 请求接口，获取数据。在请求完成的回调中，判断加载状态。 getSearchResults() { let url = '/edu/course/getCourseListByPage' let self = this api.get(url, { condition: self.data.searchContent, status: 2, pageNo: self.data.pageNo, pageCount: 10 }, function(res) { ... let array = self.data.results array = array.concat(res.content.records) // 这里记住要拼接数组 self.data.pageCount = res.content.pages // 获取pageCount的值 if (self.data.pageNo !== res.content.pages) { self.setData({ loadingStatus: 1 }) } else { self.setData({ loadingStatus: 2 }) } }, null) }, 为了实现几种加载的动画效果，我写了一个组件loading-cell，根据loadingStatus的值，实现一个动画效果。 &lt;view class='wrapper' wx:if=\"{{status == 1 || status == 3 || status == 4}}\"> &lt;image class='loading' src=\"/assets/images/loading.gif\" wx:if=\"{{status == 1}}\">&lt;/image> &lt;image class='no-data' src=\"/assets/images/a01.png\" wx:if=\"{{status == 4}}\">&lt;/image> &lt;view class='status-label'>{{util.statusString(status)}}&lt;/view> &lt;/view> 结束语整个自定义的一个上拉加载更多效果就做好了，其实，我们还可以采用一次请求后端接口，获取所有的数据，通过改变pageNo的值，按需从所有结果中拿取数据，避免加载一次请求一次结果。","path":"2019/04/02/article14/"},{"title":"搭建一个weex项目","text":"搭建一个weex项目 安装依赖 node.js 安装weex-toolkit(npm install -g weex-toolkit)，安装完可使用weex指令 在路径下新建一个空文件夹 在该文件夹下进行weex init project,npm install（安装项目依赖，到project文件目录下） npm run serve（开启服务） npm run dev（开启watch模式） 完成之后，浏览器会自动进入项目可视化页面，右边还有一个真机模拟的二维码，我们手机上下载一个weex的app就可以通过扫描该二维码进行调试了。","path":"2019/03/18/article13/"},{"title":"arcgis api + webpack前端工程化开发","text":"前言公司里的项目都涉及到地图方面到开发，使用到是Arcgis api for js框架，目前Arcgis api for js采用到是dojo框架开发，内部采用AMD加载方式和模块管理机制。项目内的组件利用dojo的widget进行开发，其中dojo的模块使用require([])按需加载。本来使用dojo开发一张图系统就可以，但是这种模式开发，不免让我们错失了许多的MVVM模式开发带来的优势。 无法使用ES6 没有部署模块热加载功能，代码存在缓存，常常需要清除缓存后手动进行刷新加载 没有采用eslint代码规范工具，无法统一代码的风格 部署的时候，必须手动修改版本信息，才能达到清除缓存的效果 代码上传时没有经过压缩，导致首屏加载时间较长 跨组件之通信过多采用dojo/Topic,window变量，容易引起命名冲突，不好管理 没有采用CSS预加载器(less,sass,stylus…)，写css比较费力，难以复用和管理 关于dojo和vuedojo 1.非MVC、MVVM框架 2.对view层操作采用直接操作dom的方式 3.dojo提供widget基本类编写组件，其组件面向对象编程 4.另外dojo非常的重，是一个巨型工具包 vue1.现代的MVVM框架2.数据驱动视图层，对view层操作无需直接操作dom3.双向数据绑定4.轻量、组件化，申明式写法5.vue-loader完美利用webpack实现HRM（热替换）6.内部采用virtual-dom和diff算法，性能良好7.拥有vue-router、vuex，更好的管理单页面应用8.社区完善，学习资料多 解决办法针对以上的问题，是时候引入webpack构建前端工程了 引入Babel编译ES6+ 对代码进行压缩 引入Less预编辑器 需要解决的问题如果我们想使用webpack进行打包，需要解决如下的问题：1.Arcgis jsapi(dojo)目前采用AMD加载机制，若在模块中使用import XXX from XXX的写法，用webpack默认打包方式去打包，框架无法识别2.如何实现import esriMap from &quot;esri/map&quot;，进而统一采用这种方式去编写3.如何接入流行的前端框架，去维护我们项目的View层4.如何引入各类loader 修改webpack配置1.利用webpack将模块打包成AMD模块，以便arcgis api框架可以识别 module.exports = { output: { libraryTarget: \"amd\" // 解决amd模块问题 } }; 2.对require的模块不做打包，统一用require.js进行加载。 module.exports = { // 末尾添加即可 (其实顺序不重要) externals: [ // 当遇到引入包含dojo/esri/dgp等模块时，不处理 function(context, request, callback) { if ( /^dojo/.test(request) || /^dojox/.test(request) || /^dijit/.test(request) || /^esri/.test(request) ) { return callback(null, \"amd \" + request); } callback(); } ] };","path":"2019/03/18/article12/"},{"title":"js异步请求总结","text":"","path":"2019/03/18/article10/"},{"title":"http请求","text":"http请求老生常谈的http请求，简单来说就是几个步骤：域名解析-&gt;发起TCP的3次握手-&gt;建立TCP连接后发起http请求-&gt;服务器响应请求，浏览器得到代码-&gt;浏览器解析代码，并请求html代码中的资源（js、css等）-&gt;浏览器对页面进行渲染呈现给用户。 域名解析域名解析是通过我们输入的域名查找到对应的ip地址，一般来说，会通过以下几种方式查找对应的ip地址：1.浏览器会首先搜索浏览器自身的DNS缓存（缓存时间大概一分钟，存储1000条缓存），查询未果，进入下一步骤 2.浏览器没有查找到对应的条目时，浏览器会搜索操作系统的DNS缓存，没有找到，继续下一步骤 3.如果操作系统中也没找到，就会去读取host文件中是否有对应的ip地址，否则继续下一步骤 4.在host文件中没有查找到，浏览器会发起一个DNS系统调用，即向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器先查找自身的缓存，找到对应的条目，如果没有找到，运营商的DNS代我们的浏览器发起迭代DNS请求。 一般情况下，以上四个步骤就能找到，但是依旧没有找到，则会进入下面几个步骤： 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。 如果第5步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器） 如果第6步也没有查询成功，那么客户端就要进行广播查找 如果第7步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样） 如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。 三次握手拿到域名解析后的ip地址，User-Agent（一般指浏览器）会以一个随机端口向服务器的web程序80端口发起TCP连接请求。这个连接请求到达服务器端后，进入网卡，然后进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序（本文就以Nginx为例），最终建立了TCP/IP的连接。1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复 2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。 3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。 为什么HTTP协议要基于TCP来实现？ 目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。 建立TCP连接后发起http请求进过TCP3次握手之后，浏览器发起了http的请求（看第包），使用的http的方法 GET 方法，请求的URL是 / ,协议是HTTP/1.0 HTTP协议请求（request）和响应（response）报文分析请求报文：HTTP协议使用TCP协议进行传输，在应用层协议发起交互之前，首先是TCP的三次握手。完成了TCP三次握手后，客户端会向服务器发出一个请求报文。请求报文的格式如下图所示： （1）请求行中的method请求行的方法，我们常知的有POST、GET、DELETE这些，但是实际上，HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。下面简单介绍一下这些请求方式: GET请求：1.向特定资源发送请求，查询数据2.在客户端，GET方式在通过URL提交数据，数据在URL中可以看到3.对于GET方式，服务器端用Request.QueryString获取变量的值4.GET方式提交的数据不能大于2KB（主要是URL长度限制）5.由于使用GET时，参数直接显示在地址栏上，所以对于非敏感数据，可以使用GET请求 POST请求：1.向指定的资源，提交数据进行处理请求，有可能创建或修改已有数据2.POST方式，数据放在HTML HEADER内提交3.对于POST方式，服务器用Request.Form获取提交的数据4.POST对提交的数据大小没有限制5.相比于GET请求，POST请求更安全 HEAD请求1.HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体。一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。这种方法可以用来获取请求中隐含的元信息，而不用传输实体本身。也经常用来测试超链接的有效性、可用性和最近的修改。2.一个HEAD请求的响应可被缓存，也就是说，响应中的信息可能用来更新之前缓存的实体。如果当前实体跟缓存实体的阈值不同（可通过Content-Length、Content-MD5、ETag或Last-Modified的变化来表明），那么这个缓存就被视为过期了。 OPTIONS预请求1.OPTIONS是浏览器对复杂跨域请求的一种处理方式，在真正请求之前，进行一次预请求，即参数OPTIONS的第一次请求，用于试探服务器的响应是否正确，如果OPTIONS请求之后的响应是拒绝的，那么就会停止第二次请求。2.OPTIONS请求产生的情况有三种：（1）请求的方式不是GET/HEAD/POST，（2）POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain，（3）请求设置了自定义的header字段 PUT请求与GET不同的是，PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。 DELETE请求请求服务器删除Request-URI所标识的资源 TRACE请求回显服务器收到的请求，主要用于测试或诊断 CONNECT请求HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 （2）请求首部 Accept：请求的对象类型。如果是“/”表示任意类型，如果是指定的类型，则会变成“type/”。 Accept-Language：使用的语言种类。 Accept-Encording：页面编码种类。 Accept-Charset：页面字符集。说到这里，需要解释以下字符集和编码的区别。字符集通常对应着一种语言，将语言中的所有字符集合起来就可以视为一种字符集，这样我们可以看出，中文并非是一种字符集，因为中文无法使用一些字符来进行表示；而编码则是将字符转换为计算机所能识别的2进制数的一种方式，例如常说的unicode，UTF-8，ANSI等等，我们在访问一些国外网站会出现乱码的原因就是因为我们浏览器所使用的编码与页面所使用的编码不能互相识别。我们常说的BIG5和GB2312都是编码。 User-Agent：提供了客户端浏览器的类型和版本。 Host：连接的目标主机，如果连接的服务器是非标准端口，在这里会出现使用的非标准端口。 Connection：对于HTTP连接的处理，keep-alive表示保持连接，如果是在响应报文中发送页面完毕就会关闭连接，状态变为close。 响应报文当收到get或post等方法发来的请求后，服务器就要对报文进行响应。状态行给出了服务器的http版本，以及一个响应代码。响应代码是服务器根据请求进行查找后得到的结果的一种反馈，共有5大类。分别以1、2、3、4、5开头。1**表示接收到请求，继续进程，在发送post后可以收到该应答。 2**表示请求的操作成功，在发送get后返回。 3**表示重发，为了完成操作必须进一步动作。 4**表示客户端出现错误。 5**表示服务器出现错误。 其余部分称为应答实体。","path":"2019/03/18/article9/"},{"title":"地图导出","text":"前言gis开发侧重于专业知识，相比于其他的前端开发领域，gis功能开发的资料相对较少，我会根据自己的日常项目和学习逐一进行整理，丰富开发资料。由于esri提供的api是用dojo框架开发的，所以在我的博客里涉及到gis开发例子的将是使用dojo语法。今天要给大家介绍一下地图导出模块核心代码。 导出地图需要以下参数：center（地图中心）、scale（导出地图比例尺）、WMTSLayers（WMTS图层）、ArcLayers（arcMap图层）、dpi（像素）、width（地图宽度）、height（地图高度）、extent（当前地图显示范围）、proxyUrl(代理地址)。根据上面的参数，我们需要封装一个ExportMapImg类，包含初始化地图、加载图层、初始化图层导出坐标系、打印几个方法。 具体实现初始化地图我们创建一个容器存放当前的地图，并顺利获取地图的空间范围、中心、比例尺等属性。 _initMap: function () { $('body').append($('&lt;div id=\"' + this.mapId + '\" style=\"height:' + this.option.height + 'px;width:' + this.option.width + 'px;z-index:-12;position:absolute;\">&lt;/div>')); this.map = new map(this.mapId, { logo: false, slider: false }); this.map.extent = this.option.extent; var defs = []; if (this.option.center) { defs.push(this.map.centerAt(this.option.center)); } if (this.option.scale) { defs.push(this.map.setScale(this.option.scale)); } all(defs).then(lang.hitch(this,this._addLayers)); } 地图创建好了以后，添加图层。常用的图层服务分为WMTS、dynamic、tiled三种。WMTS是Web地图切片服务,dynamic是动态地图服务，tiled是地图瓦片服务。不同类型的地图服务的加载方法不一样，ersi的开发者文档中有详细的例子可以参照。在我们这个例子中，添加图层是用于map的初始化，所以WMTS图层全部添加，而arcgis图层则只添加一个图层。 _addLayers: function () { var defs = []; if (this.option.WMTSLayers.length) {//保证行列号完全正确，所有wmts图层都添加 defs = this.option.WMTSLayers.map(function (item) { var def = new Deferred(); item.on('update-end', function () { def.resolve(); }); this.map.addLayer(item); return def; }, this); } if (!this.option.WMTSLayers.length &amp;&amp; this.option.ArcLayers.length) {//当未添加wmts图层时，只添加一个图层用于map初始化 var def = new Deferred(); var layerItem = this.option.ArcLayers[0]; var layer = new ArcGISDynamicMapServiceLayer(layerItem.url); layer.setVisibleLayers(layerItem.visibleLayers); layer.on('load', function () { def.resolve(); }); this.map.addLayer(layer); defs.push(def); } if (this.option.graphics.length) { var graLayer = new GraphicsLayer(); this.map.addLayer(graLayer); this.option.graphics.map(function (gra) { if (!gra.symbol) { gra.setSymbol(this._getSymbol(gra.geometry.type)); } graLayer.add(new Graphic(gra.geometry, gra.symbol)); }, this); } all(defs).then(lang.hitch(this, this._print)); }, 地图导出相对来说比较复杂，因为要将地图服务生成图片，这里我选择的是将arcgis图层使用export接口输出为png图片，并转为base64；将WMTS图层的瓦片转为base64。 /** *ArcGis 图层全部使用export接口输出png图片，并转换为base64 * @returns {Deferred} * @private */ _getExportPngs: function () { var pngsDef = new Deferred(); var $pngRoot = $('&lt;div style=\"width: 100%;height: 100%;position: absolute;\">&lt;/div>'); var defs = this.option.ArcLayers.map(function (item) { return this._exportPng(item.url, this.map.extent, this.option.dpi, this.option.height, this.option.width, item.visibleLayers, this.option.innerSR, this.option.outSR); }, this); all(defs).then(lang.hitch(this, function (results) { results.map(function (img) { $pngRoot.append($('&lt;img alt=\"\" style=\"width: 100%;height: 100%;position: inherit;\" src=\"' + img + '\">')); }); pngsDef.resolve($pngRoot); })); return pngsDef; }, /** * 将wmts图层的瓦片转为base64,并返回瓦片位置变换后的div节点 * @returns {Deferred} * @private */ _getTileLayerImgs: function () { var layersDef = new Deferred(); var scale = this.map.getScale(); var rect = this.map.__visibleRect; var $layersRoot = $('&lt;div>&lt;/div>'); var layerTileStr = 'position:absolute;border:none;margin:0;padding:0;visibility:inherit;'; var layerDivStr = 'position:absolute;overflow:visible;transition:-webkit-transform 500ms ease 0s;'; var tileLayersStr = 'position:absolute;overflow:visible;display:block;'; var layerDefs = []; this.option.WMTSLayers.map(function (item) {//图层 var layer = this.map._layers[item.id]; if (scale &lt; layer.maxScale &amp;&amp; scale > layer.minScale) return; var layerDef = new Deferred(); var $root = $('&lt;div style=\"height: ' + rect.height + 'px;width: ' + rect.width + 'px;' + 'transform: translate(' + layer.__coords_dx + 'px,' + layer.__coords_dy + 'px);' + tileLayersStr + '\">&lt;/div>'); var $layer = $('&lt;div style=\"height: ' + rect.height + 'px;width: ' + rect.width + 'px;' + layerDivStr + '\">&lt;/div>'); var tiles = layer._tileIds; var tileBs = layer._tileBounds; var tileImgs = layer._tiles; var defs = tiles.map(function (id) {//瓦片 var tileItem = tileBs[id]; var def = new Deferred(); var imgSrc = (this.option.proxyUrl === '' ? '' : this.option.proxyUrl + '?') + tileImgs[id].src; // console.log(imgSrc); this._getImgBase64(imgSrc, 'png', tileItem.height, tileItem.width).then( lang.hitch(this, function (url) { $layer.append($('&lt;img style=\"height: ' + tileItem.height + 'px;width: ' + tileItem.width + 'px;' + 'transform: translate(' + tileItem.x + 'px,' + tileItem.y + 'px);' + layerTileStr + '\" src=\"' + url + '\">')); def.resolve(); }) ); return def; }, this); $root.append($layer); all(defs).then(lang.hitch(this, function () { layerDef.resolve($root); })); layerDefs.push(layerDef); }, this); all(layerDefs).then(lang.hitch(this, function ($layers) { $layersRoot.append($layers); layersDef.resolve($layersRoot); })); return layersDef; }","path":"2019/03/18/article8/"},{"title":"关于微信登录","text":"前言做微信小程序也有小一个月了，整体来说，做的比较顺利，没有遇到特别难搞的坑，这里还是得感谢腾讯为开发者提供资料齐全的开发文档。想速度上手微信小程序的小伙伴们，戳这里，微信小程序开发者文档 微信小程序开发中，我们常常需要获取用户信息，我写小程序时是1月份，开始我并不知道接口已经做了调整，然后就直接使用button去获取用户信息，然而，调试时，出现以下提示。 具体实现当我去官方文档上查阅获取用户信息接口时，发现其已经做了一些的调整。相信大家都知道，我们在第一次使用某个小程序时会弹出一个授权框，询问用户是否允许获取用户信息。如今接口调整为在用户未授权过的情况下调用此接口，将不再出现授权弹窗，会直接进入 fail 回调。在用户已授权的情况下调用此接口，可成功获取用户信息。 竟然不再出现授权窗口了，那我们就需要使用button进行引导。 &lt;button class='wexin-login' open-type=\"getUserInfo\" lang=\"zh_CN\" bindgetuserinfo=\"onGotUserInfo\"> &lt;image class='wexin-icon' src='/assets/images/content/share_wechat.png' /> &lt;text class='wexin-text' open-type=\"getUserInfo\" bindgetuserinfo=\"onGotUserInfo\" lang=\"zh_CN\">微信登录&lt;/text> &lt;/button> 逻辑部分处理为: getWXCode: function() { var that = this; wx.login({ success: function(res) { api.post('/edu/user/WechatAPPLogin', { encryptedData: that.data.userInfo.encryptedData, iv: that.data.userInfo.iv, code: res.code }, function(res) { that.onBack() getApp().globalData.userId = res.content.userInfo.id }.bind(this), function(res) { wx.showToast({ title: res.msg, icon: 'none', duration: 2000 }) }) } }) }","path":"2019/03/17/article7/"},{"title":"制作一个添加工作经验的功能","text":"前言前几天给一个app做项目经验添加功能时，自己犯了几个错误，于是决定总结一下，算是写成一个demo，给大家参考一下吧。 具体实现 添加工作经验的页面如图1，这是一个用户的详情页面，每条工作经验的右上角，添加了删除按钮，区域的下方有继续添加经历的按钮。说白了，这个功能就是实现对表单数据的增、删、改功能。首先，我从后端接口中获取到用户的工作经验数据（也可能是一个空数组），这块的逻辑我们很容易写出来，就是根据获取到的值进行遍历即可。 &lt;div v-for=\"(item, index) in experiences\" :key=\"item.id\"> &lt;div class=\"detail\"> &lt;image class=\"closeIcon\" :src=\"iconPath('icon_gb_small')\" @click=\"removeExperience(item.id)\">&lt;/image> &lt;text class=\"unselect-txt\">开始时间&lt;/text> &lt;input class=\"input\" type=\"date\" v-model=\"item.startDate\">&lt;/input> &lt;image class=\"icon\" :src=\"iconPath('icon_pen')\">&lt;/image> &lt;/div> &lt;div class=\"detail\"> &lt;text class=\"unselect-txt\">结束时间&lt;/text> &lt;input class=\"input\" type=\"date\" v-model=\"item.endDate\">&lt;/input> &lt;image class=\"icon\" :src=\"iconPath('icon_pen')\">&lt;/image> &lt;/div> &lt;div class=\"detail2\"> &lt;text class=\"unselect-txt\">从业说明：&lt;/text> &lt;textarea v-model=\"item.introduction\" class=\"textarea\">&lt;/textarea> &lt;/div> &lt;div class=\"list-gap\">&lt;/div> &lt;/div> &lt;div> &lt;div class=\"next-btn\" @click=\"addNextExperience\"> &lt;text class=\"next-button\">继续添加经历&lt;/text> &lt;/div> &lt;/div> &lt;div class=\"btn\" @click=\"addUserMaterial\"> &lt;text style=\"font-size: 28px;color: #ffffff;\">完成&lt;/text> &lt;/div> 我们在input和textarea中使用v-model进行数据的双向绑定。我们都知道，vue实现了一套虚拟的DOM，我们不需要直接操作DOM元素，只需要操作数据就可重新渲染页面。而背后的原理得益于高效的Diff算法，具体的原理我不在这阐述。key的作用是为了高效的更新虚拟DOM。所以为了让vue可以区分他们，我们在做循环或相同标签元素的过渡切换时，都有必要使用到key属性，所以在上述循环中我们指定项目经验的id为key值。下面我们开始写新增事件和删除事件。新增 addNextExperience() { this.experienceId++ this.experiences.push({id: this.experienceId, startDate: '', endDate: '', introduction: ''}) } 删除 removeExperience(index) { this.experiences = this.experiences.filter(function (experience) { return (index !== experience.id); }) } 新增事件我使用了一个全局变量experienceId为id赋值，这个experienceId的值为多少合适呢。我们上面通过接口拿到了当前用户的工作经验值，每条工作经验都有一个id号，我首先想到的就是，在我新增时，这个id号的起始值应该为当前用户的工作经验的id号的最大值+1，这样做的原因是为了保证从后端接口取出的id号和我任意一条新增数据的id号都不会相同，这样一来，每一条工作经验的id号才不会出现重复的情况。","path":"2019/03/17/article6/"},{"title":"ES6常用总结","text":"文章参考来源:[ECMAScript 6 入门] 阮一峰的文档讲的比较的详细，我当时在看的时候，也是没有太多的耐心，加上没有实战的话，忘的很快，所以决定根据每个章节，抽离出重要的知识点，将es6整个过一遍，文章中的示例均来源于文档。 一、let和const let：申明一个变量，所申明的变量只在let命令所载代码块内有效。（1）循环中使用，循环体外引用报错 for (let i = 0; i &lt; 10; i++) { } console.log(i); // ReferenceError: i is not defined （2）不存在变量提升，即必须声明后才可以使用 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; （3）暂时性死区，作用域内存在let命令后，所声明的变量就绑定在该区域内，不再受外界的影响 var tmp = 123; if (true) { tmp = 'abc'; // ReferenceError let tmp; } （4）不允许重复声明 // 报错 function func() { let a = 10; var a = 1; } // 报错 function func() { let a = 10; let a = 1; } const：声明一个只读常数，一旦声明，常量的值不可改变（1）只声明，不赋值，变量报错，与let一致，const只在声明所在的块级作用域内有效。 const foo; // SyntaxError: Missing initializer in const declaration if (true) { const MAX = 5; } MAX // Uncaught ReferenceError: MAX is not defined （2）和let一致，也存在暂存性死区（3）const保证变量指向的内存地址所保存的值不变，所以对于变量为数值、字符串、布尔值这样的简单数据类型，值直接保存在变量所指向的内存地址中，因此直接等于常量。但对于复合型数据，如对象和数组，变量指向但是内存地址，保存但是一个指向实际数据的指针，const只能保证这个指针是固定的，而它指向的数据结构是否可变是不可控制的。 const foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 foo.prop = 235; foo.prop // 235 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: \"foo\" is read-only 二、变量的解构赋值 数组的解构赋值（1）解构不成功，变量的值变为undefined。不完全匹配的情况下，解构依然成功。 let [a, b, c] = [1, 2, 3]; let [foo, [[bar], baz]] = [1, [[2], 3]]; // foo:1,bar:2,baz:3 let [head, ...tail] = [1, 2, 3, 4]; // head:1,tail:[2,3,4] let [x, y, ...z] = ['a']; // x:'a',y:undefined,z:[] let [x, y] = [1, 2, 3]; // x:1,y:2 （2）等号右边为不可遍历的解构，解构报错 // 报错 let [foo] = 1; let [foo] = false; let [foo] = NaN; let [foo] = undefined; let [foo] = null; let [foo] = {}; （3）对于 Set 结构，也可以使用数组的解构赋值 let [x, y, z] = new Set(['a', 'b', 'c']); x // \"a\" （4）指定默认值，指定默认值时，如果数组成员是null，默认值不会生效，因为null不严格等于undefined。如果默认值是一个表达式时，这个表达式是惰性的，即只有用到时，才会进行求值。 let [foo = true] = []; foo // true let [x, y = 'b'] = ['a']; // x='a', y='b' let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' let [x = 1] = [undefined]; x // 1 let [x = 1] = [null]; x // null function f() { console.log('aaa'); } let [x = f()] = [1]; x // 1 （5）默认值可以引用解构赋值的其他变量，但是该变量必须已经声明 let [x = 1, y = x] = []; // x=1; y=1 let [x = 1, y = x] = [2]; // x=2; y=2 let [x = 1, y = x] = [1, 2]; // x=1; y=2 let [x = y, y = 1] = []; // ReferenceError: y is not defined 对象的解构赋值（1）对象解构不需要按顺序来取值，变量与属性名相同，即可取到值，解构失败，变量的值等于undefined let { bar, foo } = { foo: 'aaa', bar: 'bbb' }; foo // \"aaa\" bar // \"bbb\" let { baz } = { foo: 'aaa', bar: 'bbb' }; baz // undefined （2）对象解构也可以用于嵌套结构的对象 let obj = { p: [ 'Hello', { y: 'World' } ] }; let { p: [x, { y }] } = obj; x // \"Hello\" y // \"World\" （3）如果解构模式是嵌套的对象，而子对象的父属性不存在，将会报错 // 报错 let {foo: {bar}} = {baz: 'baz'}; （4）对象的解构赋值可以取到继承的属性 const obj1 = {}; const obj2 = { foo: 'bar' }; Object.setPrototypeOf(obj1, obj2); const { foo } = obj1; foo // \"bar\" （5）对象的解构也可以指定默认值，默认值生效的条件是，对象的属性严格等于undefined var {x = 3} = {x: undefined}; x // 3 var {x = 3} = {x: null}; x // null （6）对数组进行对象属性解构 let arr = [1, 2, 3]; let {0 : first, [arr.length - 1] : last} = arr; first // 1 last // 3 字符串解构赋值 const [a, b, c, d, e] = 'hello'; a // \"h\" b // \"e\" c // \"l\" d // \"l\" e // \"o\" let {length : len} = 'hello'; len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象，由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 let {toString: s} = 123; s === Number.prototype.toString // true let { prop: x } = undefined; // TypeError let { prop: y } = null; // TypeError *函数参数解构赋值 [[1, 2], [3, 4]].map(([a, b]) => a + b); // [ 3, 7 ] 函数参数的解构也可以使用默认值，如果解构失败，参数值等于默认值，如果参数是一个对象，对这个对象进行解构，得到参数的值 function move({x, y} = { x: 0, y: 0 }) { return [x, y]; } move({x: 3, y: 8}); // [3, 8] move({x: 3}); // [3, undefined] move({}); // [undefined, undefined] move(); // [0, 0] // undefined就会触发函数参数的默认值 [1, undefined, 3].map((x = 'yes') => x); // [ 1, 'yes', 3 ] 不能使用圆括号（1）变量声明语句 // 全部报错 let [(a)] = [1]; let {x: (c)} = {}; let ({x: c}) = {}; let {(x: c)} = {}; let {(x): c} = {}; let { o: ({ p: p }) } = { o: { p: 2 } }; （2）函数参数声明 // 报错 function f([(z)]) { return z; } // 报错 function f([z,(x)]) { return x; } （3）赋值语句模式 // 全部报错 ({ p: a }) = { p: 42 }; ([a]) = [5]; [({ p: a }), { x: c }] = [{}, {}]; 可使用圆括号赋值语句非模式部分，可使用圆括号 [(b)] = [3]; // 正确 ({ p: (d) } = {}); // 正确 [(parseInt.prop)] = [3]; // 正确 三、Set和Map数据结构 set：set数据结构类似于数组，但是成员的值是唯一的，没有重复值；set本身是一个构造函数，用来生成set数据结构 （1）去除数组重复成员 const set = new Set([1, 2, 3, 4, 4]); [...set] // [1, 2, 3, 4] （2）set四个方法 add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 （3）Array.from方法可以将 Set 结构转为数组 function dedupe(array) { return Array.from(new Set(array)); } dedupe([1, 1, 2, 3]) // [1, 2, 3] （4）遍历操作，set结构没有键名，只有键值，所以keys和values方法得到的值是相同的 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 let set = new Set(['red', 'green', 'blue']); for (let item of set.keys()) { console.log(item); } // red // green // blue for (let item of set.values()) { console.log(item); } // red // green // blue for (let item of set.entries()) { console.log(item); } // [\"red\", \"red\"] // [\"green\", \"green\"] // [\"blue\", \"blue\"] （5）数组的map和filter方法用于 Set let a = new Set([1, 2, 3]); let b = new Set([4, 3, 2]); // 并集 let union = new Set([...a, ...b]); // Set {1, 2, 3, 4} // 交集 let intersect = new Set([...a].filter(x => b.has(x))); // set {2, 3} // 差集 let difference = new Set([...a].filter(x => !b.has(x))); // Set {1}","path":"2019/03/16/article5/"},{"title":"正则表达式化整为零","text":"前言写代码也有一段时间了，正则表达式是经常会用得到，每次遇到一些匹配时，就上网找，因为自己一直都在排斥学正则表达式，但是拖着不是程序猿的好习惯，那今天就来好好整理下。不求全部学会，只求见到认识。正则表达式常用的几种操作方法有：match、search、split、findall、sub、replace。 基本字符特殊字符特殊字符就是具有特殊含义的字符。在正则表达式中，这些特殊字符匹配的意义各有不同，如果需要在字符串中查找这些特殊符号，就需要在其前面加一个\\进行转义。 特殊字符 含义 $ 匹配输入字符串的结尾 （） 标记一个子表达的开始和结束位置 * 匹配前面的表达式零次或多次 + 匹配前面的子表达式一次或多次 . 匹配除换行符\\n 之外的任何单字符 [ 标记一个中括号表达式的开始 ？ 匹配前面的子表达式零次或一次 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合 { 标记限定符表达式的开始 指明两项之间的一个选择 贪婪和非贪婪 在上表中列举的*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 定位符定位符用来描述字符串或单词的边界，其中^和$分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B表示非单词边界。 Tip：不能将限定符和定位符一起使用。 带反斜杠的元字符普通字符前加反斜杠还是普通字符，但是有些字符加上反斜杠之后就会变成元字符 语法1.检索字符我们既可以检索普通字符也可以检索表情符号，因为表情符其实也是一个字符，使用match方法可以返回一个数组，包含检索字符内容，被检索到到索引号。 'hello world'.match(/w/); > [\"w\", index: 6, input: \"hello world\", groups: undefined] 'hello 😀world'.match(/😀/); > [\"😀\", index: 6, input: \"hello 😀world\", groups: undefined] 2.匹配文本开始和结束我们用^匹配文本的开始，用$匹配文本的结束。匹配文本的第一个字符时，必须是匹配文本的第一个字符，否则匹配不成功。 'hello'.match(/^h/); > [\"h\", index: 0, input: \"hello\", groups: undefined] 'hello'.match(/a^h/); > null 'hello'.match(/o$/); > [\"o\", index: 4, input: \"hello\", groups: undefined] 3.元字符 元字符 含义 \\b 匹配一个单词边界 \\B 匹配一个非单词边界 \\d 匹配一个数字字符 \\D 匹配一个非数字字符 \\s 匹配一个空白字符 \\S 匹配一个非空白字符 \\w 匹配一个字母或一个数字或一个下划线 \\W 匹配一个字母、数字和下划线之外的字符 元字符上述表格中已列举出来了，元字符的大写相当于取反。匹配单词边界的对中文边界是无效的。 // \\b 匹配单词边界 'hello world'.match(/\\bworld$/); > [\"world\", index: 6, input: \"hello world\", groups: undefined] '你 好'.match(/\\B好$/); [\"好\", index: 2, input: \"你 好\", groups: undefined] // \\d 匹配数字边界 '123'.match(/\\d2/); [\"12\", index: 0, input: \"123\", groups: undefined] // \\s匹配单个空白字符 'a b'.match(/\\s/); [\" \", index: 1, input: \"a b\", groups: undefined] // \\w匹配单个字母数字下划线 'a b'.match(/\\w/); [\"a\", index: 0, input: \"a b\", groups: undefined] 4.量词限定符用来指定正则表达式的一个给定组件必须要出现多次才能匹配 字符 描述 * 匹配前面的子表达式零次或多次 + 匹配前面的子表达式一次或多次 ？ 匹配前面的子表达式零次或一次 {n} n是一个非负整数。匹配确定的n次 {n,} 至少匹配n次 {n,m} n&lt;=m，最少匹配n次最多匹配m次 // 非贪婪模式 'https'.match(/http(s)?/); [\"https\", \"s\", index: 0, input: \"https\", groups: undefined] 'gooooogle'.match(/go{2,5}gle/); [\"gooooogle\", index: 0, input: \"gooooogle\", groups: undefined] 5.字符组方括号在正则中表示一个区间,我们称之为字符组。 'grey or gray'.match(/gr[ae]y/); [\"grey\", index: 0, input: \"grey or gray\", groups: undefined] 6.捕获组和非捕获组[ES2018]圆括号的意思是将它其中的字符集合打包成一个整体,然后量词就可以操作这个整体了。 'i love you very very very much'.match(/i love you (very )+much/); [\"i love you very very very much\", \"very \", index: 0, input: \"i love you very very very much\", groups: undefined] 7.正则内捕获正则内捕获使用\\数字的形式根据对应前面的圆括号捕获内容，这种捕获的引用也称为反向引用。 '&lt;span>hello world&lt;/span>'.match(/&lt;([a-zA-Z]+)>.*&lt;\\/\\1>/); > [\"&lt;span>hello world&lt;/span>\", \"span\", index: 0, input: \"&lt;span>hello world&lt;/span>\", groups: undefined] 8.正则外捕获 'hello **world**'.replace(/\\*{2}(.*)\\*{2}/, '&lt;strong>$1&lt;/strong>'); \"hello &lt;strong>world&lt;/strong>\" 9.非捕获组当我们需要匹配捕获组,但是又不需要捕获组结果时,我们可以使用非捕获组(?:pattern) 'industry'.match(/industr(?:y|ies)/); [\"industry\", index: 0, input: \"industry\", groups: undefined] 10.或 'aA'.match(/a|A/); [\"a\", index: 0, input: \"aA\", groups: undefined] 11.零宽断言零宽断言零宽：匹配一个位置，本身没有宽度；断言：断言之前或者之后应该有什么或没有什么（1）零宽肯定先行断言(?=)[正向肯定预查] 'TypeScript JavaScript javascript'.match(/\\b\\w{4}(?=Script\\b)/); [\"Type\", index: 0, input: \"TypeScript JavaScript javascript\", groups: undefined] （2）零宽肯定后行断言(?&lt;=)[ES2018] [反向肯定预查] '演员高圆圆 将军霍去病 演员霍思燕'.match(/(?&lt;=演员)霍\\S+/); [\"霍思燕\", index: 14, input: \"演员高圆圆 将军霍去病 演员霍思燕\", groups: undefined] （3）零宽否定先行断言(?!)[正向否定预查]否定就是没有,就是要求一段文本,后面一定不要紧跟一段指定文本 'TypeScript Perl JavaScript'.match(/\\b\\w{4}(?!Script\\b)/); [\"Perl\", index: 11, input: \"TypeScript Perl JavaScript\", groups: undefined] （4）零宽否定后行断言(?&lt;!)[ES2018] [反向否定预查]要求一段文本,前面一定不跟某一段指定文本 '演员高圆圆 将军霍去病 演员霍思燕'.match(/(?&lt;!演员)霍\\S+/); [\"霍去病\", index: 8, input: \"演员高圆圆 将军霍去病 演员霍思燕\", groups: undefined] 12.修饰符（1）g修饰符(global) 默认情况下,正则从左向右匹配,只要匹配到结果就会结束,g修饰符会开启全局匹配模式,找到所有的匹配结果（2）i修饰符(ignoreCase)默认情况话,正则是区分大小写的,i修饰符的作用是可以全局忽略大小写.（3）m修饰符(multiline)默认情况下，^和$匹配的是文本的开始和结束，加上m修饰符，它们的含义就变成了多行的行首和行尾,支持多行搜索（4）y修饰符(sticky粘连)[ES6]y修饰符有和g修饰符重合的功能，它们都是全局匹配,不同在于,g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义 'a bag with a tag has a mag'.match(/\\wag/g); [\"bag\", \"tag\", \"mag\"] 'a bag with a tag has a mag'.match(/\\wag/y); null 'bagtagmag'.match(/\\wag/y); [\"bag\", index: 0, input: \"bagtagmag\", groups: undefined] 'bagtagmag'.match(/\\wag/gy); [\"bag\", \"tag\", \"mag\"] （5）s修饰符(singleline)[ES2018]s修饰符的作用是让.可以匹配任意单个字符。（6）u修饰符(unicode)[ES6]有些Unicode字符超过一个字节,正则无法正确识别,可用u修饰符来处理。 ES6变化ES6中,将字符串的4个正则方法(match,replace,search,split)在语言内部全部调用RegExp的实例方法,从而做到所有与正则相关的方法,全部定义在RegExp对象上。","path":"2019/03/15/article4/"},{"title":"JavaScript内存优化","text":"内存泄漏当程序持续无法释放其使用的临时内存时就会发生内存泄漏。JavaScript提供GC垃圾回收进行自动内存管理，其机制是找出不再使用的变量，释放其占用的内存，但是这个内存不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 不再使用的变量就是生命周期结束的变量，即局部变量（全局变量的生命周期直到浏览器卸载才会结束）。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束。闭包中由于内部函数的原因，外部函数并不能算是结束。 避免内存泄漏(1)避免DOM节点创建中闪屏IE中有一类典型的内存泄漏模式称为DOM插入顺序内存泄漏。当创建动态当DOM节点时，我们确保上层元素首先被附着，然后是底层。如果顺序反过来，可能导致内存泄漏。当要创建的 DOM 树很大时，这种从上而下的创建 DOM 节点的方式可能会造成浏览器视图的闪烁。一个好的办法是在 DOM 树渲染期间通过样式”display:none”把最顶层父节点隐藏起来，直到整个 DOM 树都创建好之后，再把顶层父节点展现出来。 var frameNode = domCon.create('div', { \"style\": {display: \"none\"} }, this.domNode); // 创建 frameNode 节点下的子节点树 // 当子节点树创建好之后，显示整个 frameNode 节点树 domStyle.set(frameNode, \"display\",'block') (2)DOM节点循环引用当Javascript对象引用DOM元素并且DOM元素当属性引用Javascript对象时，循环应用发生并导致DOM节点泄漏。 var obj = document.getElementById(\"id\"); document.getElementById(\"id\").expandoProperty = obj; 若需要这么使用，在准备移除节点时，先将元素expandoProperty属性设置为null。 (3)Dom节点的引用 &lt;html> &lt;body> &lt;div id=\"refA\"> &lt;ul> &lt;li>&lt;a>&lt;/a>&lt;/li> &lt;li>&lt;a>&lt;/a>&lt;/li> &lt;li>&lt;a id=\"refB\">&lt;/a>&lt;/li> &lt;/ul> &lt;/div> &lt;/body> &lt;/html> &lt;script> var refA = document.getElementById('refA'); var refB = document.getElementById('refB'); refB=null; refB引用了refA。它们之间是dom树父节点和子节点的关系。如果在此时移除refA,或者将refA对象设置为null，那么这个dom节点在浏览器内存中依然存在。因为refB对refA存在引用，所以除非在把refB释放，否则dom节点内存会一直存在浏览器中无法被回收掉。(4)闭包 window.onload = function() { var obj = document.getElementById(\"element\"); // this creates a closure over \"element\" // and will leak if not handled properly. obj.onclick = function(evt) { alert(\"leak the element DIV\"); }; }; 应用程序之后删除了element节点，JavaScript 引用仍然会持有孤立节点。这个孤立节点将会造成内存泄露。(5)定时器setTimeout setInterval当不需要setInterval或者setTimeout时，定时器没有被clear，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏。 ChromeDevTools工具以上介绍了几种内存泄漏的情况，那么我们在项目中如何发现可能存在内存泄漏的地方。 PerformancePerformance按时间顺序展示页面加载过程及后续过程的网络请求、页面渲染过程、JS运行时长、页面帧率、CPU/GPU使用情况等1，在timeline中观测页面资源加载情况（时长，顺序），降低页面加载时长。2，在timeline中观测FPS情况，观测底下的JS执行耗时，能分析出哪部分耗时过长，导致帧率下降 Memory Memory监控CPU使用情况，内存分配情况等，用于做深入分析 1、Record Allocation profiles(allocation sampling)监控函数执行期花费的时间。点击下方的Start按钮（也可以点击左边的黑色圆圈），这时候Chrome会开始记录网页的方法执行，然后我们点击界面的按钮来执行。（用来查看分配给各函数的内存大小）最后再点击右边区域的Stop按钮（或者左边的红色圆圈），这时监控就结束了。左边Profiles会列出一个文件，单击可以看到如下界面从上面结果中，可以发现，在点击开始，运行操作界面之后，点击停止，该工具记录了在这个期间，执行过的一些函数，以及执行这些函数所分配的内存状况。可以转换chart图表模式查看。2、Record Allocation timeline它的作用是为我们拍下一系列的快照（频率为50ms），为我们检测在启用它的时候每个对象的生存情况。形象一点说就是假如拍摄内存快照的功能是照相那么它功能相当于录像。当启用start按钮的时候它便开始录像，直到结束。左侧区域上半部分有一些蓝色和灰色的柱条。灰色的表示监控这段时间内活跃过的对象，但是被回收掉了。蓝色的表示依旧没有没回收.（用来查看实时的内存分配及回收情况）。3、Heap snapshotSummary(概要)视图能帮你通过构造函数分组寻找对象(和对象的内存使用)。该视图对找出DOM内存泄漏很有帮助。Comparison(对照)视图能够通过显示哪些对象内存被正确的回收了来搜寻内存泄漏。通常在一个操作前后记录两个(或更多)的内存使用快照。它是通过察看释放的内存和引用数目的差导来察看是否有内存泄漏，并找到原因。Constructor(构造函数)表示所有通过该构造函数生成的对象 Distance 对象到达GC根的最短距离 Shallow size 对应构造函数生成的对象的shallow sizes(直接占用内存) Retained size 展示了对应对象所占用的最大内存。 function a() { var obj = [1,2,.......n]; return function() { //js作用域的原因，在此闭包运行的上下文中可以访问到obj这个对象 console.log(obj); } } var b = a(); 正常情况下，a函数执行完毕 obj占用的内存会被回收，但是此处a函数返回了一个函数表达式，其中obj因为js的作用域的特殊性一直存在，所以我们可以说b引用了obj。每次访问b对象的时候都可以访问到obj，说明内存未被回收 所以对于obj来说直接占用内存[1,2,….n], 而b依赖obj，所obj是b的最大内存。","path":"2019/03/15/article3/"},{"title":"地图出图/打印","text":"地图打印输出作为webgis较为常用的一个模块，由于其实现过程和参数较为复杂，对其功能的调整和扩展，通常是前端开发中一个较为头疼的事情 。本文将结合项目经验介绍前端实现地图导出三个主要途径的实现过程及注意事项。功能有限，内容不全面，如有错误和不足请指出。 实现方式纯前端支持wmts服务（1）、arcgis服务（2）和GraphicLayer（3）三种类型组合导出图片。当系统中接入wmts服务时，ArcgisServer自带的打印服务和前端截图插件不能满足需求（截图wmts图层为空白），具体原因就未做深入；刚好项目碰到这个问题，好几个重要功能都受到影响,因此有了这个解决方案 wmts服务添加到map后arcgisapi会根据当前视图计算用于显示瓦片，并通过二维变换让所有图片拼接显示。这些变换的参数在图层对象中都能获取到，根据这些变换参数可以将瓦片手动拼成‘一张图片’。功能主要解决的问题还是资源跨域问题，瓦片要转换为base64编码的图片，然后拼合成一张图片，最后在使用前端截图插件dom-to-image或html2canvas进行图片生成。 1.初始化map对象，div显示层级为负，设置map的中心点和比例尺2.添加底图和要素图形(1)有wmts:为保证wmts服务的瓦片获取正确无误，必须全部添加到map上，监听每个服务的update-end事件，不添加arcgis服务(2)无wmts:arcgis服务只需添加一个即可，我们只是需要map初始化完成后的extent，监听服务的load事件3.待上述事件全部抛出，开始打印准备，创建打印根节点元素(层级设为负) (1)wmts服务瓦片获取并转为base64，拼合做位置变换，完成后返回服务图片容器的元素节点 (2)arcgis服务export图片，dpi、bbox、height、width、sr、visibleLayers，每个服务都要进行请求，都完成后返回服务图片容器的元素节点（因为gp服务导出的图片不透明，所以每个服务都要请求）4、将3中返回的元素加入打印根结点元素，克隆map中要素图层的svg元素，加入打印根节点元素5、使用截图插件出图，让完成事件抛出 var exportImg = new ExportMapImg({ center: this.map.extent.getCenter(), scale: this.map.getScale(), WMTSLayers: [new WMTS(url,...),new WMTS(url,...)], ArcLayers: [{url:'http://192.168.200.113:6080/arcgis/rest/services/CDYZT/CHDZTGH/MapServer',visibleLayers:[101]}], dpi: this.dpi, width: width, height: height }); on.once(exportImg, 'export-success', function (url) { exportImg.downLoad(url); exportImg = null; }); IE支持GraphicLayer导出html2canvas在ie中使用不支持svg的输出；将svg输出为Blob地址和svgbase64地址赋给img，然后绘制在canvas会出现跨域而污染画布不能使用toBlob()、toDataURL()、getImageData()；IE报‘SCRIPT5022: SecurityError’错误：网上说的是跨域原因，解决方案有3个：img. crossOrigin设置 、插件和ajax从后台获取1.插件：canvg.js，以及canvg的依赖rgbcolor.js、stackblur-canvas.js，在plugins目录下，请在项目中引用，本人的引入位置：成功(只需要引入插件依赖即可，处理部分已经封装)2.后台（一个传入什么返回什么的接口）：失败(SCRIPT5022: SecurityError)从使用了后台测试后基本排除了跨域的原因，因为直接使用base64Png图片不设置图片跨域绘制到canvas里，canvas的像素操作不受影响，这也就说明问题可能出在IE的canvas对象对svg图片的支持上所以目前不考虑后台转化支持的话，前端只能通过canvg.js将svg绘制在canvas里（个人见解，如果大家有更好的方式请务必告知一下） DPI相关内容dpi=96:每英寸点数1in=2.54cm一般情况下，提高export接口导出图片的精度，如下图：（地址）单纯提高dpi。从结果来看范围是一致了，但是出图的比例尺变化了将dpi和尺寸乘以相同倍数，如下图：导出范围一致，比例尺一致举例：假如需要打印一张照片2inX2in（dpi=100）这时像素尺寸应为200pxX200px 假如还需要打印一张照片2inX2in (dpi=300) 这时像素尺寸应为600pxX600px当只有像素尺寸200pxX200px图片，打印一张2inX2in的照片dpi=300，打印机会进行栅格化处理，将（200px→600px）X (200px→600px)输出打印，这种情况下打印的照片应该会出现平时所说的马赛克以上内容个人见解，正确性未知；为什么要讲这个内容？因为wmts服务切片一般都是默认的dpi=96，所以想要输出更高精度的图片，也就和上面例子中一样，要将切片栅格化放大处理后，在输出，结果就是严重失真因此对更高dpi未做支持，初始化参数中有这个内容，那只有arcgis服务export接口会使用到，传高了服务返回还会变慢，所以默认96； GP 服务GP服务图片导出：一张图和多规基线用的就是这个方式，但是很多项目都接入的wmts服务，导出的图片没有wmts图层的内容，也就有了前面的前端解决方案为了对照，我们还是说一下GP服务的使用：（地址）打印模板可配置的内容还有很多详见(api) //创建地图打印对象 var printMap = new PrintTask(this.config.serviceUrl); //创建地图打印模版 var template = new PrintTemplate(); //创建地图的打印参数，参数里面包括：模版和地图 var params = new PrintParameters(); //输出图片的空间参考 printMap.outSpatialReference = this.map.spatialReference; //打印图片的各种参数 template.exportOptions = { width: this.map.width, height: this.map.height, dpi: 96 }; //打印输出的格式 template.format = 'JPG'; //输出地图的布局 template.layout = 'MAP_ONLY'; // PrintTemplate //设置参数地图 params.map = this.map; //设置参数模版 params.template = template; //运行结果 printMap.execute(params, lang.hitch(this, function (result) { if (result) { console.log(result); } }), lang.hitch(this, function (error) { console.log(error); })); }","path":"2019/03/15/article/"},{"title":"多坐标系下地图面积测量","text":"function calArea(polygon, spatialReference) { if (spatialReference.isWebMercator() || spatialReference.wkid == \"4326\" || spatialReference.wkid == \"4490\") { return geometryEngine.geodesicArea(polygon, \"square-meters\") } else if (spatialReference.wkid == \"4610\") { return geodesicUtils.geodesicAreas([polygon], esriUnits.SQUARE_METERS)[0]; } else { return geometryEngine.planarArea(polygon, \"square-meters\") } }","path":"2019/03/13/article2/"},{"title":"我理解的原型链","text":"原型链，开始看资料时觉得还能理解，到后面就有点绕晕了，在看了几篇文章之后，我将关键点剥离出来，进行整理，这样一来，整个原型链就得到了一个很好的理解。那么首先，我们要明确几个概念。 函数（Function）拥有prototype属性，对象（除了null）拥有__proto__ 除了__proto__属性，对象还拥有constructor属性，这个属性使得一个对象指向一个函数，即指向该对象的构造函数，每个对象都具有一个构造函数（本身拥有或继承而来），Function对象的构造函数是它本身，所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function函数。 对象所拥有的__proto__是当访问一个对象当属性时，没有找到该属性，就会去它的__proto__属性所指向的那个对象（父对象）里找，一直寻找，直到__proto__属性的值为null，返回undefined，通过__proto__属性将对象连接起来的这条链路就是原型链。 在js中一切都为对象，正是因为这个，函数也是一个对象，所以函数在作为对象时拥有__proto__和constructor，作为函数时又拥有prototype属性。 根据上面几个概念，我们来做几个测试。 1.函数及其实例化对象之间的关系 var obj=function(){}; // 定义一个函数，此时它既是函数也是对象，所以同时拥有prototype和__proto__属性 console.log(obj.prototype) // => {constructor: ƒ} console.log(obj.__proto__) // => ƒ () { [native code] } var o=new obj(); // 实例化一个o对象 console.log(o.__proto__) // =>{constructor: ƒ} 我理解的就是obj的prototype属性constructor指向obj本身，而其实例化的o的__proto__属性也是指向obj原型，故相等 o.__proto__ === obj.prototype // => true 现在我们知道对象o的__proto__属性的constructor也是ƒ (){}，而obj本身就是一个ƒ (){}，自然相等 o.__proto__.constructor===obj // => true 2.obj与构造函数Function的关系我们知道每个对象都具有一个__proto__属性，而每个构造函数都有一个prototype方法，每个对象的__proto__属性指向自身构造函数的prototype； obj.__proto__===Function.prototype // => true obj.__proto__.constructor===Function // => true 3.Function和ObjectECMAScript规定了两个特殊的内置对象：Object和Function。他们的特殊性在于，他们本身既是对象又是函数，而他们同时也是对象和函数的构造器。 // 构造器Function的构造器是它自身 Function.constructor=== Function // => true // 构造器Object的构造器是Function （所有构造器的constructor都指向Function） Object.constructor === Function // => true // 构造器Function的__proto__是一个特殊的匿名函数function() {} console.log(Function.__proto__) // => function() {} // 这个特殊的匿名函数的__proto__指向Object的prototype原型 Function.__proto__.__proto__ === Object.prototype // => true // Object的__proto__指向Function的prototype，也就是上面所述的特殊匿名函数 Object.__proto__ === Function.prototype // => true Function.__proto__ === Function.prototype // => true 注： 所有的构造器的constructor都指向Function Function的__proto__指向一个匿名函数，而这个匿名函数的__proto__指向Object.prototype instanceofinstanceof运算符用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上 function Person() {} console.log(Object instanceof Object); //true //第一个Object的原型链：Object=> //Object.__proto__ => Function.prototype=>Function.prototype.__proto__=>Object.prototype //第二个Object的原型：Object=> Object.prototype console.log(Function instanceof Function); //true //第一个Function的原型链：Function=>Function.__proto__ => Function.prototype //第二个Function的原型：Function=>Function.prototype console.log(Function instanceof Object); //true //Function=> //Function.__proto__=>Function.prototype=>Function.prototype.__proto__=>Object.prototype //Object => Object.prototype console.log(Person instanceof Function); //true //Person=>Person.__proto__=>Function.prototype //Function=>Function.prototype console.log(String instanceof String); //false //第一个String的原型链：String=> //String.__proto__=>Function.prototype=>Function.prototype.__proto__=>Object.prototype //第二个String的原型链：String=>String.prototype console.log(Boolean instanceof Boolean); //false //第一个Boolean的原型链：Boolean=> //Boolean.__proto__=>Function.prototype=>Function.prototype.__proto__=>Object.prototype //第二个Boolean的原型链：Boolean=>Boolean.prototype console.log(Person instanceof Person); //false //第一个Person的原型链：Person=> //Person.__proto__=>Function.prototype=>Function.prototype.__proto__=>Object.prototype //第二个Person的原型链：Person=>Person.prototype","path":"2018/03/18/article11/"}]}