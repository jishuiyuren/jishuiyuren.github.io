{"pages":[],"posts":[{"title":"vue内部运行机制源码分析——模版编译","text":"编译vue源码中虚拟dom构建过程经历了template编译成AST语法树-&gt;转换为render函数，最终返回一个VNode。 compile编译过程分为parse、optimize、generate三个阶段，最终得到render function parse：用正则表达式的方式解析template模版的指令、class、style等数据，形成AST（abstract syntax tree，抽象语法树），是源代码的抽象语法结构的树状表现形式。 optimize：此步骤主要是优化性能，标记static静态节点，当update更新界面时，会有一个patch的过程，diff算法会直接跳过该静态节点，从而减少比较的过程，优化patch的性能。 generate：将AST转化为render function字符串的过程，得到的结果是render字符串及staticRenderFns字符串。 源码解析（1）parseparse用正则方式将template模版进行字符串解析，得到指令、class、style等数据，形成AST。关于正则表达式如何写，在以前的笔记中有讲述，下面主要列举parse过程中用到的正则表达式。 const ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*'; const singleAttrIdentifier = /([^\\s\"'&lt;>/=]+)/ const singleAttrAssign = /(?:=)/ const singleAttrValues = [ /\"([^\"]*)\"+/.source, /'([^']*)'+/.source, /([^\\s\"'=&lt;>`]+)/.source ] const attribute = new RegExp( '^\\\\s*' + singleAttrIdentifier.source + '(?:\\\\s*(' + singleAttrAssign.source + ')' + '\\\\s*(?:' + singleAttrValues.join('|') + '))?' ) const qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')' const startTagOpen = new RegExp('^&lt;' + qnameCapture) const startTagClose = /^\\s*(\\/?)>/ const endTag = new RegExp('^&lt;\\\\/' + qnameCapture + '[^>]*>') const defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g const forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/ a. advance我们解析template采用循环进行字符串匹配的方式，所以每解析完一段字符就将已经匹配的去掉，头部的指针指向接下来需要匹配的部分。 function advance (n) { index += n html = html.substring(n) } b.parseHTML首先我们需要定义个 parseHTML函数，在里面我们循环解析 template 字符串。parseHTML 会用 while 来循环解析 template 字符串，用正则在匹配到标签头、标签尾以及文本的时候分别进行不同的处理。直到整个template 被解析完毕。 function parseHTML () { while(html) { let textEnd = html.indexOf('&lt;'); if (textEnd === 0) { if (html.match(endTag)) { //...process end tag continue; } if (html.match(startTagOpen)) { //...process start tag continue; } } else { //...process text continue; } } } c. 解析template标签parseStartTag用来解析起始标签 function parseStartTag () { const start = html.match(startTagOpen); if (start) { const match = { tagName: start[1], attrs: [], start: index } advance(start[0].length); let end, attr while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) { advance(attr[0].length) match.attrs.push({ name: attr[1], value: attr[3] }); } if (end) { match.unarySlash = end[1]; advance(end[0].length); match.end = index; return match } } } 接下来使用 startTagClose 与 attribute 两个正则分别用来解析标签结束以及标签内的属性。这段代码用 while 循环一直到匹配到 startTagClose 为止，解析内部所有的属性。 let end, attr while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) { advance(attr[0].length) match.attrs.push({ name: attr[1], value: attr[3] }); } if (end) { match.unarySlash = end[1]; advance(end[0].length); match.end = index; return match } d. stack此外，我们需要维护一个 stack栈来保存已经解析好的标签头，这样我们可以根据在解析尾部标签的时候得到所属的层级关系以及父标签。同时我们定义一个 currentParent变量用来存放当前标签的父标签节点的引用， root变量用来指向根标签节点。 const stack = []; let currentParent, root; 知道这个以后，我们优化一下 parseHTML ，在 startTagOpen 的 if逻辑中加上新的处理。 我们将 startTagMatch 得到的结果首先封装成 element，这个就是最终形成的AST的节点，标签节点的type 为 1。 if (html.match(startTagOpen)) { const startTagMatch = parseStartTag(); const element = { type: 1, tag: startTagMatch.tagName, lowerCasedTag: startTagMatch.tagName.toLowerCase(), attrsList: startTagMatch.attrs, attrsMap: makeAttrsMap(startTagMatch.attrs), parent: currentParent, children: [] } if(!root){ root = element } if(currentParent){ currentParent.children.push(element); } stack.push(element); currentParent = element; continue; } 然后让 root指向根节点的引用。 if(!root){ root = element } 接着我们将当前节点的 element放入父节点 currentParent 的 children数组中。 if(currentParent){ currentParent.children.push(element); } 最后将当前节点 element 压入 stack 栈中，并将 currentParent 指向当前节点，因为接下去下一个解析如果还是头标签或者是文本的话，会成为当前节点的子节点，如果是尾标签的话，那么将会从栈中取出当前节点，这种情况我们接下来要讲。 stack.push(element); currentParent = element; continue; 其中的 makeAttrsMap 是将 attrs 转换成map格式的一个方法。 function makeAttrsMap (attrs) { const map = {} for (let i = 0, l = attrs.length; i &lt; l; i++) { map[attrs[i].name] = attrs[i].value; } return map } parseEndTag同样，我们在parseHTML中加入对尾标签的解析函数，为了匹配如“”。 const endTagMatch = html.match(endTag) if (endTagMatch) { advance(endTagMatch[0].length); parseEndTag(endTagMatch[1]); continue; } 用 parseEndTag来解析尾标签，它会从 stack 栈中取出最近的跟自己标签名一致的那个元素，将 currentParent指向那个元素，并将该元素之前的元素都从 stack中出栈。这里可能有同学会问，难道解析的尾元素不应该对应 stack 栈的最上面的一个元素才对吗？其实不然，比如说可能会存在自闭合的标签，如“”，或者是写了“”但是没有加上“&lt; /span&gt;”的情况，这时候就要找到 stack 中的第二个位置才能找到同名标签。 function parseEndTag (tagName) { let pos; for (pos = stack.length - 1; pos >= 0; pos--) { if (stack[pos].lowerCasedTag === tagName.toLowerCase()) { break; } } if (pos >= 0) { stack.length = pos; currentParent = stack[pos]; } } parseText 最后是解析文本，这个比较简单，只需要将文本取出，然后有两种情况，一种是普通的文本，直接构建一个节点 push 进当前 currentParent的 children 中即可。还有一种情况是文本是如“”这样的 Vue.js 的表达式，这时候我们需要用 parseText来将表达式转化成代码。 text = html.substring(0, textEnd) advance(textEnd) let expression; if (expression = parseText(text)) { currentParent.children.push({ type: 2, text, expression }); } else { currentParent.children.push({ type: 3, text, }); } continue; 我们会用到一个parseText函数。 function parseText (text) { if (!defaultTagRE.test(text)) return; const tokens = []; let lastIndex = defaultTagRE.lastIndex = 0 let match, index while ((match = defaultTagRE.exec(text))) { index = match.index if (index > lastIndex) { tokens.push(JSON.stringify(text.slice(lastIndex, index))) } const exp = match[1].trim() tokens.push(`_s(${exp})`) lastIndex = index + match[0].length } if (lastIndex &lt; text.length) { tokens.push(JSON.stringify(text.slice(lastIndex))) } return tokens.join('+'); } processIf与processFor 最后介绍一下如何处理“v-if”以及“v-for”这样的 Vue.js 的表达式的，这里我们只简单介绍两个示例中用到的表达式解析。 我们只需要在解析头标签的内容中加入这两个表达式的解析函数即可，在这时“v-for”之类指令已经在属性解析时存入了 attrsMap 中了。 if (html.match(startTagOpen)) { const startTagMatch = parseStartTag(); const element = { type: 1, tag: startTagMatch.tagName, attrsList: startTagMatch.attrs, attrsMap: makeAttrsMap(startTagMatch.attrs), parent: currentParent, children: [] } processIf(element); processFor(element); if(!root){ root = element } if(currentParent){ currentParent.children.push(element); } stack.push(element); currentParent = element; continue; } 首先我们需要定义一个 getAndRemoveAttr 函数，用来从el的 attrsMap属性或是 attrsList 属性中取出 name对应值。 function getAndRemoveAttr (el, name) { let val if ((val = el.attrsMap[name]) != null) { const list = el.attrsList for (let i = 0, l = list.length; i &lt; l; i++) { if (list[i].name === name) { list.splice(i, 1) break } } } return val } 比如说解析示例的 div 标签属性。 getAndRemoveAttr(el, 'v-for'); 可有得到“item in sz”。 有了这个函数这样我们就可以开始实现 processFor 与 processIf了。 “v-for”会将指令解析成 for 属性以及 alias 属性，而“v-if”会将条件都存入 ifConditions 数组中。 function processFor (el) { let exp; if ((exp = getAndRemoveAttr(el, 'v-for'))) { const inMatch = exp.match(forAliasRE); el.for = inMatch[2].trim(); el.alias = inMatch[1].trim(); } } function processIf (el) { const exp = getAndRemoveAttr(el, 'v-if'); if (exp) { el.if = exp; if (!el.ifConditions) { el.ifConditions = []; } el.ifConditions.push({ exp: exp, block: el }); } } （2）optimizeoptimize主要是用来优化，这个涉及到后面要讲patch的过程，因为 patch的过程实际上是将 VNode节点进行一层一层的比对，然后将「差异」更新到视图上。 那么一些静态节点是不会根据数据变化而产生变化的，这些节点我们没有比对的需求，是不是可以跳过这些静态节点的比对，从而节省一些性能呢？ 那么我们就需要为静态的节点做上一些「标记」，在 patch 的时候我们就可以直接跳过这些被标记的节点的比对，从而达到「优化」的目的。 经过 optimize 这层的处理，每个节点会加上 static 属性，用来标记是否是静态的。 isStatic首先实现一个isStatic 函数，传入一个 node判断该 node是否是静态节点。判断的标准是当type 为 2（表达式节点）则是非静态节点，当 type 为 3（文本节点）的时候则是静态节点，当然，如果存在 if 或者 for这样的条件的时候（表达式节点），也是非静态节点。 function isStatic (node) { if (node.type === 2) { return false } if (node.type === 3) { return true } return (!node.if &amp;&amp; !node.for); } markStaticmarkStatic为所有的节点标记上 static，遍历所有节点通过 isStatic 来判断当前节点是否是静态节点，此外，会遍历当前节点的所有子节点，如果子节点是非静态节点，那么当前节点也是非静态节点。 function markStatic (node) { node.static = isStatic(node); if (node.type === 1) { for (let i = 0, l = node.children.length; i &lt; l; i++) { const child = node.children[i]; markStatic(child); if (!child.static) { node.static = false; } } } } markStaticRoots接下来是 markStaticRoots 函数，用来标记 staticRoot（静态根）。这个函数实现比较简单，简单来将就是如果当前节点是静态节点，同时满足该节点并不是只有一个文本节点左右子节点（作者认为这种情况的优化消耗会大于收益）时，标记 staticRoot 为 true，否则为false。 function markStaticRoots (node) { if (node.type === 1) { if (node.static &amp;&amp; node.children.length &amp;&amp; !( node.children.length === 1 &amp;&amp; node.children[0].type === 3 )) { node.staticRoot = true; return; } else { node.staticRoot = false; } } } optimize有了以上的函数，就可以实现 optimize 了。 function optimize (rootAst) { markStatic(rootAst); markStaticRoots(rootAst); } （3）generategenerate会将 AST 转化成render funtion字符串，最终得到 render的字符串以及 staticRenderFns字符串。 首先带大家感受一下真实的 Vue.js 编译得到的结果。 with(this){ return (isShow) ? _c( 'div', { staticClass: \"demo\", class: c }, _l( (sz), function(item){ return _c('span',[_v(_s(item))]) } ) ) : _e() } 实现一个generate genIf 处理if条件的 genIf函数。 function genIf (el) { el.ifProcessed = true; if (!el.ifConditions.length) { return '_e()'; } return `(${el.ifConditions[0].exp})?${genElement(el.ifConditions[0].block)}: _e()` } genFor然后是处理for 循环的函数。 function genFor (el) { el.forProcessed = true; const exp = el.for; const alias = el.alias; const iterator1 = el.iterator1 ? `,${el.iterator1}` : ''; const iterator2 = el.iterator2 ? `,${el.iterator2}` : ''; return `_l((${exp}),` + `function(${alias}${iterator1}${iterator2}){` + `return ${genElement(el)}` + '})'; } genText处理文本节点的函数。 function genText (el) { return `_v(${el.expression})`; } genElement接下来实现一下 genElement，这是一个处理节点的函数，因为它依赖 genChildren 以及genNode ，所以这三个函数放在一起讲。 genElement会根据当前节点是否有if或者 for标记然后判断是否要用 genIf 或者 genFor处理，否则通过 genChildren 处理子节点，同时得到 staticClass、class等属性。 genChildren 比较简单，遍历所有子节点，通过 genNode处理后用“，”隔开拼接成字符串。 genNode则是根据type来判断该节点是用文本节点 genText还是标签节点genElement来处理。 function genNode (el) { if (el.type === 1) { return genElement(el); } else { return genText(el); } } function genChildren (el) { const children = el.children; if (children &amp;&amp; children.length > 0) { return `${children.map(genNode).join(',')}`; } } function genElement (el) { if (el.if &amp;&amp; !el.ifProcessed) { return genIf(el); } else if (el.for &amp;&amp; !el.forProcessed) { return genFor(el); } else { const children = genChildren(el); let code; code = `_c('${el.tag},'{ staticClass: ${el.attrsMap &amp;&amp; el.attrsMap[':class']}, class: ${el.attrsMap &amp;&amp; el.attrsMap['class']}, }${ children ? `,${children}` : '' })` return code; } } generate最后我们使用上面的函数来实现 generate，其实很简单，我们只需要将整个AST传入后判断是否为空，为空则返回一个 div 标签，否则通过 generate来处理。 function generate (rootAst) { const code = rootAst ? genElement(rootAst) : '_c(\"div\")' return { render: `with(this){return ${code}}`, } } 小结经历过这些过程以后，我们已经把 template 顺利转成了 render function 了，接下来我们将介绍 patch的过程，来看一下具体 VNode 节点如何进行差异的比对。","path":"2019/04/14/article17/"},{"title":"vue内部运行机制源码分析——初始化和挂载","text":"vue全局运行机制vue的内部流程分为5个步骤： 进行初始化和挂载：init及mount 模版编译：compile，编译成渲染函数render function 进行响应式依赖收集：render function =&gt; getter、setter =&gt; watcher 进行 update =&gt; patch 的过程以及使用队列异步更新的策略 依赖收集的同时产生Virtal DOM ，render function 被转为VNode节点 通过diff算法进行patch更新视图 博客拆分几篇文章进行归纳，本章讲解一下初始化和挂载。 初始化和挂载在new Vue()之后，vue 调用 _init函数进行初始化，它会初始化：生命周期、事件、props、methods、data、computed和watch等。 初始化之后调用$mount挂载组件，如果运行时编译，不存在render function 但是存在template的情况，会进行编译。 其中最重要的是会通过Object.defineProperty设置getter和setter函数，用来实现响应式和依赖收集。 源码解析响应式系统基本原则vue.js是MMVVM框架，数据结果是JavaScript对象，但是它能通过对这些对象进行操作时，影响对应对视图，其核心实现就是响应式系统。（1）Object.defineProperty讲到响应式系统，不可避免要说到Object.defineProperty，Vue是基于它实现响应式系统的。 /* obj: 目标对象 prop: 需要操作的目标对象的属性名 descriptor: 描述符 return value 传入对象 */ Object.defineProperty(obj, prop, descriptor) descriptor具有一些属性： enumerable，属性是否可以枚举，默认false configurable，属性是否可以被修改或删除，默认false get，获取属性的方法 set，设置属性的方法 （2）observer（可观察的） 我们知道在init的阶段会进行初始化，从而对数据进行响应化，我们定义一个defineReactive方法，该方法通过Object.defineProperty来实现对对象的响应化，入参是一个obj（需要绑定的对象），key（obj的某个属性），val（具体的值）。经过defineReactive方法处理后，obj的属性key在「读」的时候会触发reactiveGetter方法，而属性在「写」的时候会触发reactiveSetter方法。 function defineReactive (obj, key, val) { Object.defineProperty(obj, key, { enumerable: true, /* 属性可枚举 */ configurable: true, /* 属性可被修改或删除 */ get: function reactiveGetter () { return val; /* 实际上会依赖收集，下一小节会讲 */ }, set: function reactiveSetter (newVal) { if (newVal === val) return; cb(newVal); } }); } // 更新视图 function cb (val) { /* 渲染视图 */ console.log(\"视图更新啦～\"); } 当然，这只是对一个对象进行该操作，我们需要通过递归的方式对所有的对象进行defineReactive处理。下面的方法，使用循环的方式来实现一个observer的逻辑。 function observer (value) { if (!value || (typeof value !== 'object')) { return; } Object.keys(value).forEach((key) => { defineReactive(value, key, value[key]); }); } 响应式的一个大致的逻辑已经介绍完成，最后，我们来将observer封装为一个Vue。在Vue的构造函数中，对options的data进行处理，这里的data就是我们平时在vue组件中写的data属性（实际上是一个函数，这里当作一个对象来简单处理）。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;script> function observer (value) { if (!value || (typeof value !== 'object')) { return; } Object.keys(value).forEach((key) => { defineReactive(value, key, value[key]); }); } function cb (val) { console.log(\"视图更新啦～\", val); } function defineReactive (obj, key, val) { Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { return val; }, set: function reactiveSetter (newVal) { if (newVal === val) return; val = newVal; cb(newVal); } }); } class Vue { constructor(options) { this._data = options.data; observer(this._data); } } let o = new Vue({ data: { test: \"I am test.\" } }); o._data.test = \"hello,test.\"; &lt;/script> &lt;/body> &lt;/html> 依赖收集追踪原理（1）为什么要依赖收集？举个🌰我们现在有这样一个对象： new Vue({ template: `&lt;div> &lt;span>{{text1}}&lt;/span> &lt;span>{{text2}}&lt;/span> &lt;div>`, data: { text1: 'text1', text2: 'text2', text3: 'text3' } }); 我们修改text3的数据 this.text3 = 'modify text3'; 但是因为视图中不需要使用到text3，这时，我们不可能去通知上述所讲的cb函数去进行视图的修改。 再举个🌰 这时我们拥有一个全局对象，有多个地方使用到该全局对象。 let globalObj = { text1: 'text1' }; let o1 = new Vue({ template: `&lt;div> &lt;span>{{text1}}&lt;/span> &lt;div>`, data: globalObj }); let o2 = new Vue({ template: `&lt;div> &lt;span>{{text1}}&lt;/span> &lt;div>`, data: globalObj }); 如果这时候我们修改gloablObj的text1的内容，就需要同时通知o1和o2两个实例进行视图的更新。这就是我们为什么需要进行依赖收集的原因。 （2）订阅者我们实现一个订阅者Dep，用来存放watcher观察者对象。 class Dep { constructor () { /* 用来存放Watcher对象的数组 */ this.subs = []; } /* 在subs中添加一个Watcher对象 */ addSub (sub) { this.subs.push(sub); } /* 通知所有Watcher对象更新视图 */ notify () { this.subs.forEach((sub) => { sub.update(); }) } } （3）观察者watcher class Watcher { constructor () { /* 在new一个Watcher对象时将该对象赋值给Dep.target，在get中会用到 */ Dep.target = this; } /* 更新视图的方法 */ update () { console.log(\"视图更新啦～\"); } } Dep.target = null; （4）依赖收集我们把上面的defineReactive方法修改，增加一个Dep类对象，用来收集watcher对象。在对象被读的时候，触发reactiveGetter函数，把当前的watcher对象收集到Dep类中，之后当对象被写时触发reactiveSetter方法，通知Dep类调用notify来触发Watcher对象的update方法更新对应的视图。 function defineReactive (obj, key, val) { /* 一个Dep类对象 */ const dep = new Dep(); Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { /* 将Dep.target（即当前的Watcher对象存入dep的subs中） */ dep.addSub(Dep.target); return val; }, set: function reactiveSetter (newVal) { if (newVal === val) return; /* 在set的时候触发dep的notify来通知所有的Watcher对象更新视图 */ dep.notify(); } }); } class Vue { constructor(options) { this._data = options.data; observer(this._data); /* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */ new Watcher(); /* 在这里模拟render的过程，为了触发test属性的get函数 */ console.log('render~', this._data.test); } } 小结到这里，响应式系统和依赖收集就讲完了，现在进行总结一下。 首先在observer的过程中会注册get方法，该方法用来进行「依赖收集」。 在它的闭包中会有一个Dep对象，用这个对象来存放watcher对象，依赖收集的过程就是将watcher实例存放到对应的Dep对象中去的。 get方法让当前的watcher对象存放到它的subs（addSub）中。 在数据更新时，set会调用Dep对象的notify方法，通知它内部的所有watcher对象进行视图更新。","path":"2019/04/13/article16/"},{"title":"地图出图/打印","text":"地图打印输出作为webgis较为常用的一个模块，由于其实现过程和参数较为复杂，对其功能的调整和扩展，通常是前端开发中一个较为头疼的事情 。本文将结合项目经验介绍前端实现地图导出三个主要途径的实现过程及注意事项。功能有限，内容不全面，如有错误和不足请指出。 实现方式纯前端支持wmts服务（1）、arcgis服务（2）和GraphicLayer（3）三种类型组合导出图片。当系统中接入wmts服务时，ArcgisServer自带的打印服务和前端截图插件不能满足需求（截图wmts图层为空白），具体原因就未做深入；刚好项目碰到这个问题，好几个重要功能都受到影响,因此有了这个解决方案 wmts服务添加到map后arcgisapi会根据当前视图计算用于显示瓦片，并通过二维变换让所有图片拼接显示。这些变换的参数在图层对象中都能获取到，根据这些变换参数可以将瓦片手动拼成‘一张图片’。功能主要解决的问题还是资源跨域问题，瓦片要转换为base64编码的图片，然后拼合成一张图片，最后在使用前端截图插件dom-to-image或html2canvas进行图片生成。 1.初始化map对象，div显示层级为负，设置map的中心点和比例尺2.添加底图和要素图形(1)有wmts:为保证wmts服务的瓦片获取正确无误，必须全部添加到map上，监听每个服务的update-end事件，不添加arcgis服务(2)无wmts:arcgis服务只需添加一个即可，我们只是需要map初始化完成后的extent，监听服务的load事件3.待上述事件全部抛出，开始打印准备，创建打印根节点元素(层级设为负) (1)wmts服务瓦片获取并转为base64，拼合做位置变换，完成后返回服务图片容器的元素节点 (2)arcgis服务export图片，dpi、bbox、height、width、sr、visibleLayers，每个服务都要进行请求，都完成后返回服务图片容器的元素节点（因为gp服务导出的图片不透明，所以每个服务都要请求）4、将3中返回的元素加入打印根结点元素，克隆map中要素图层的svg元素，加入打印根节点元素5、使用截图插件出图，让完成事件抛出 var exportImg = new ExportMapImg({ center: this.map.extent.getCenter(), scale: this.map.getScale(), WMTSLayers: [new WMTS(url,...),new WMTS(url,...)], ArcLayers: [{url:'http://192.168.200.113:6080/arcgis/rest/services/CDYZT/CHDZTGH/MapServer',visibleLayers:[101]}], dpi: this.dpi, width: width, height: height }); on.once(exportImg, 'export-success', function (url) { exportImg.downLoad(url); exportImg = null; }); IE支持GraphicLayer导出html2canvas在ie中使用不支持svg的输出；将svg输出为Blob地址和svgbase64地址赋给img，然后绘制在canvas会出现跨域而污染画布不能使用toBlob()、toDataURL()、getImageData()；IE报‘SCRIPT5022: SecurityError’错误：网上说的是跨域原因，解决方案有3个：img. crossOrigin设置 、插件和ajax从后台获取1.插件：canvg.js，以及canvg的依赖rgbcolor.js、stackblur-canvas.js，在plugins目录下，请在项目中引用，本人的引入位置：成功(只需要引入插件依赖即可，处理部分已经封装)2.后台（一个传入什么返回什么的接口）：失败(SCRIPT5022: SecurityError)从使用了后台测试后基本排除了跨域的原因，因为直接使用base64Png图片不设置图片跨域绘制到canvas里，canvas的像素操作不受影响，这也就说明问题可能出在IE的canvas对象对svg图片的支持上所以目前不考虑后台转化支持的话，前端只能通过canvg.js将svg绘制在canvas里（个人见解，如果大家有更好的方式请务必告知一下） DPI相关内容dpi=96:每英寸点数1in=2.54cm一般情况下，提高export接口导出图片的精度，如下图：（地址）单纯提高dpi。从结果来看范围是一致了，但是出图的比例尺变化了将dpi和尺寸乘以相同倍数，如下图：导出范围一致，比例尺一致举例：假如需要打印一张照片2inX2in（dpi=100）这时像素尺寸应为200pxX200px 假如还需要打印一张照片2inX2in (dpi=300) 这时像素尺寸应为600pxX600px当只有像素尺寸200pxX200px图片，打印一张2inX2in的照片dpi=300，打印机会进行栅格化处理，将（200px→600px）X (200px→600px)输出打印，这种情况下打印的照片应该会出现平时所说的马赛克以上内容个人见解，正确性未知；为什么要讲这个内容？因为wmts服务切片一般都是默认的dpi=96，所以想要输出更高精度的图片，也就和上面例子中一样，要将切片栅格化放大处理后，在输出，结果就是严重失真因此对更高dpi未做支持，初始化参数中有这个内容，那只有arcgis服务export接口会使用到，传高了服务返回还会变慢，所以默认96； GP 服务GP服务图片导出：一张图和多规基线用的就是这个方式，但是很多项目都接入的wmts服务，导出的图片没有wmts图层的内容，也就有了前面的前端解决方案为了对照，我们还是说一下GP服务的使用：（地址）打印模板可配置的内容还有很多详见(api) //创建地图打印对象 var printMap = new PrintTask(this.config.serviceUrl); //创建地图打印模版 var template = new PrintTemplate(); //创建地图的打印参数，参数里面包括：模版和地图 var params = new PrintParameters(); //输出图片的空间参考 printMap.outSpatialReference = this.map.spatialReference; //打印图片的各种参数 template.exportOptions = { width: this.map.width, height: this.map.height, dpi: 96 }; //打印输出的格式 template.format = 'JPG'; //输出地图的布局 template.layout = 'MAP_ONLY'; // PrintTemplate //设置参数地图 params.map = this.map; //设置参数模版 params.template = template; //运行结果 printMap.execute(params, lang.hitch(this, function (result) { if (result) { console.log(result); } }), lang.hitch(this, function (error) { console.log(error); })); }","path":"2019/04/09/article/"},{"title":"视频播放进度记录","text":"前言微信小程序提供一个video组件支持视频播放，开发者文档上可以看到，该组件提供了很多可选属性，具体的可查阅微信小程序开发文档。 具体实现为了有效记录视频的播放进度，我准备在视频播放过程中每十秒一周期、视频暂停时、视频播放结束时上报一次当前时间。使用initial-time让视频从当前时间开始进行播放。 &lt;video class=\"video\" autoplay=\"true\" src=\"{{url}}\" controls bindtimeupdate='bindtimeupdate' bindpause='bindpause' bindended='bindended' controls initial-time=\"{{currentTime}}\">&lt;/video> bindtimeupdate事件可以直接获取到播放视频的当前时间和总时长。每隔十秒去请求一次接口，将时间存储下来。 bindtimeupdate(res) { this.data.currentTime = parseInt(res.detail.currentTime) // 当前时间 this.data.duration = parseInt(res.detail.duration) // 总时长 if (this.data.flag) return this.data.flag = setInterval(this.getPlayTime, 10000); // 十秒上报一次 } 暂停时记录一次当前时间，并清除setInterval事件，防止持续上报。bindended与bindpause事件逻辑一致。 bindpause(e) { if (this.data.currentTime !== this.data.duration) { this.data.isEnd = false } this.getPlayTime() if (this.data.flag) { clearInterval(this.data.flag) this.data.flag = null } } 实现效果在我的学习页面，可以看到每个视频的已播放进度条。进入视频，视频从当前视频时间继续播放。","path":"2019/04/02/article15/"},{"title":"微信小程序的上拉加载功能","text":"前言这段时间一直在弄智荟那个微信小程序，发现，很多地方的列表加载都需要用到上拉加载更多这个功能，一开始，看了官方文档觉得蛮简单的，但是在实际写的过程中还是踩了一点的坑，所以就在这做一个简单的总结。 前端页面在前端页面中，我们使用scroll-view组件去实现这个上拉加载的功能。用bindscrolltolower去触发加载更多事件。 &lt;scroll-view bindscrolltolower=\"loadMore\" scroll-y=\"true\" class='scroll-content' style=\"height:{{scrollHeight}}px;\"> &lt;view wx:for='{{results}}' wx:key='{{index}}' bindtap='onDetail' data-item='{{item}}'> &lt;view class='search-items'> &lt;view class='content-detail'> &lt;image class='search-img' resize=\"cover\" src='{{item.image}}' /> &lt;view class='search-content'> &lt;text class='search-title'>{{item.name}}&lt;/text> &lt;view class='cell-gap'>&lt;/view> &lt;text class='search-type'>{{type[item.type-1]}}&lt;/text> &lt;/view> &lt;/view> &lt;/view> &lt;/view> &lt;loading-cell status=\"{{loadingStatus}}\">&lt;/loading-cell> &lt;/scroll-view> 在scroll-view中我动态的改变了其高度，而初始该高度的获取，我使用了微信提供的getSystemInfo来获取。其实，一开始我踩了一个坑，就是这里并没有去这样拿高度，而是根据页面的情况，自己写死了一个高度，以至于一直没有实现效果。 onLoad: function(options) { var that = this; wx.getSystemInfo({ success: function(res) { that.setData({ scrollHeight: res.windowHeight }); } }); } 我申明了三个变量：pageNo（页码）、pageCount（总页数）、scrollHeight（滚动高度）。 data: { pageNo: 1, pageCount: 0, scrollHeight: 0 }, loadMore监听页数的变化，当前页码小于总页数时，请求接口，获取结果。 loadMore(e) { if (this.data.pageNo &lt; this.data.pageCount) { this.data.pageNo++ this.getSearchResults() } } 请求接口，获取数据。在请求完成的回调中，判断加载状态。 getSearchResults() { let url = '/edu/course/getCourseListByPage' let self = this api.get(url, { condition: self.data.searchContent, status: 2, pageNo: self.data.pageNo, pageCount: 10 }, function(res) { ... let array = self.data.results array = array.concat(res.content.records) // 这里记住要拼接数组 self.data.pageCount = res.content.pages // 获取pageCount的值 if (self.data.pageNo !== res.content.pages) { self.setData({ loadingStatus: 1 }) } else { self.setData({ loadingStatus: 2 }) } }, null) }, 为了实现几种加载的动画效果，我写了一个组件loading-cell，根据loadingStatus的值，实现一个动画效果。 &lt;view class='wrapper' wx:if=\"{{status == 1 || status == 3 || status == 4}}\"> &lt;image class='loading' src=\"/assets/images/loading.gif\" wx:if=\"{{status == 1}}\">&lt;/image> &lt;image class='no-data' src=\"/assets/images/a01.png\" wx:if=\"{{status == 4}}\">&lt;/image> &lt;view class='status-label'>{{util.statusString(status)}}&lt;/view> &lt;/view> 结束语整个自定义的一个上拉加载更多效果就做好了，其实，我们还可以采用一次请求后端接口，获取所有的数据，通过改变pageNo的值，按需从所有结果中拿取数据，避免加载一次请求一次结果。","path":"2019/04/02/article14/"},{"title":"搭建一个weex项目","text":"搭建一个weex项目有了跨平台开发之后，我产生了浓烈的兴趣，一直想做app类的开发，但是不想去学客户端开发，正好，有了这样的一个机会，尝试着新建一个项目，学习一下。 weex项目新建流程 安装依赖 node.js 安装weex-toolkit(npm install -g weex-toolkit)，安装完可使用weex指令 在路径下新建一个空文件夹 在该文件夹下进行weex init project,npm install（安装项目依赖，到project文件目录下） npm run serve（开启服务） npm run dev（开启watch模式） 完成之后，浏览器会自动进入项目可视化页面，右边还有一个真机模拟的二维码，我们手机上下载一个weex的app就可以通过扫描该二维码进行调试了。","path":"2019/03/18/article13/"},{"title":"arcgis api + webpack前端工程化开发","text":"前言公司里的项目都涉及到地图方面到开发，使用到是Arcgis api for js框架，目前Arcgis api for js采用到是dojo框架开发，内部采用AMD加载方式和模块管理机制。项目内的组件利用dojo的widget进行开发，其中dojo的模块使用require([])按需加载。本来使用dojo开发一张图系统就可以，但是这种模式开发，不免让我们错失了许多的MVVM模式开发带来的优势。 无法使用ES6 没有部署模块热加载功能，代码存在缓存，常常需要清除缓存后手动进行刷新加载 没有采用eslint代码规范工具，无法统一代码的风格 部署的时候，必须手动修改版本信息，才能达到清除缓存的效果 代码上传时没有经过压缩，导致首屏加载时间较长 跨组件之通信过多采用dojo/Topic,window变量，容易引起命名冲突，不好管理 没有采用CSS预加载器(less,sass,stylus…)，写css比较费力，难以复用和管理 关于dojo和vuedojo 1.非MVC、MVVM框架 2.对view层操作采用直接操作dom的方式 3.dojo提供widget基本类编写组件，其组件面向对象编程 4.另外dojo非常的重，是一个巨型工具包 vue1.现代的MVVM框架2.数据驱动视图层，对view层操作无需直接操作dom3.双向数据绑定4.轻量、组件化，申明式写法5.vue-loader完美利用webpack实现HRM（热替换）6.内部采用virtual-dom和diff算法，性能良好7.拥有vue-router、vuex，更好的管理单页面应用8.社区完善，学习资料多 解决办法针对以上的问题，是时候引入webpack构建前端工程了 引入Babel编译ES6+ 对代码进行压缩 引入Less预编辑器 需要解决的问题如果我们想使用webpack进行打包，需要解决如下的问题：1.Arcgis jsapi(dojo)目前采用AMD加载机制，若在模块中使用import XXX from XXX的写法，用webpack默认打包方式去打包，框架无法识别2.如何实现import esriMap from &quot;esri/map&quot;，进而统一采用这种方式去编写3.如何接入流行的前端框架，去维护我们项目的View层4.如何引入各类loader 修改webpack配置1.利用webpack将模块打包成AMD模块，以便arcgis api框架可以识别 module.exports = { output: { libraryTarget: \"amd\" // 解决amd模块问题 } }; 2.对require的模块不做打包，统一用require.js进行加载。 module.exports = { // 末尾添加即可 (其实顺序不重要) externals: [ // 当遇到引入包含dojo/esri/dgp等模块时，不处理 function(context, request, callback) { if ( /^dojo/.test(request) || /^dojox/.test(request) || /^dijit/.test(request) || /^esri/.test(request) ) { return callback(null, \"amd \" + request); } callback(); } ] };","path":"2019/03/18/article12/"},{"title":"js异步编程总结","text":"前言Javascript是单线程的，而实现异步编程就显得及其重要。在ES6以前，我们要实现异步编程可通过：（1）回调事件；（2）事件监听（订阅/发布）；（3）Promise对象。ES6中提供了Generator函数(协程coroutine)。ES7中使用了async和await实现。 Javascript异步编程方法 回调函数回调函数实现异步应该是用的比较频繁的，它是在一个耗时操作之后执行某个操作。 //callback hell doSomethingAsync1(function(){ doSomethingAsync2(function(){ doSomethingAsync3(function(){ doSomethingAsync4(function(){ doSomethingAsync5(function(){ // code... }); }); }); }); }); 上面的代码，在业务逻辑逐渐复杂的情况下，层层叠加，这就是典型的”回调地狱”，这种代码维护起来特别痛苦，同时，我们回调函数之外是无法捕获到回调内的异常。 事件监听 事件监听也是比较常用的方法，它使用逻辑分离方式，对代码解耦很有用处。我们将不变的部分封装在组件内部，提供外部调用，将变化的部分暴露在外部使用。相当于事件的设计是组件的接口设计。 //发布和订阅事件 var events = require('events'); var emitter = new events.EventEmitter(); emitter.on('event1', function(message){ console.log(message); }); emitter.emit('event1', \"message for you\"); 事件监听的实现方式是，一个订阅方订阅某个事件，在需要触发该事件时让发布方直接使用emit发出一个事件并携带相应的参数，订阅方收到该事件信息并处理。 Promise Promise对象通过同步的写法实现异步的操作，避免层层嵌套的回调，使得代码逻辑清晰，易于维护。 （1）Promise的链式写法Promise.prototype.then()方法返回一个新的Promise对象，采用这种链式的写法就是，一个then后面可以跟着另一个then。如果前面的回调返回的是一个Promise对象，那么后面的回调会等待前一个Promise对象有了返回结果之后再进一步调用。 //原生Primose顺序嵌套回调示例 var fs = require('fs') var read = function (filename){ var promise = new Promise(function(resolve, reject){ fs.readFile(filename, 'utf8', function(err, data){ if (err){ reject(err); } resolve(data); }) }); return promise; } read('./text1.txt') .then(function(data){ console.log(data); return read('./text2.txt'); }) .then(function(data){ console.log(data); }) .catch(function(err){ console.log(\"error caught: \" + err); }) 在上述代码中，第一个then先输出text1.txt的内容后返回read(‘./text2.txt’)，这里返回了一个新的Promise实例，第二个then里面指定了异步读取text2.txt文件的回调函数。与Promise.prototype.then()对应的还有一个Promise.prototype.catch方法，用于指定发生错误时的回调函数。 （2）Promise异步并发异步并发是，我们如果不需要某些事件按顺序执行，而是同时执行，就可以使用异步并发执行。Promise.all()用于将多个Promise包装成一个新的Promise实例（var p = Promise.all([p1,p2,p3])）。Promise.all可接受一个数组作为参数，数组中的每个值是Promise对象实例。执行结果的状态由p1,p2,p3决定，可分为两种情况： a. 只有p1,p2,p3的状态都变为fullfilled，P的状态才会变成fullfilled，此时p1,p2,p3的返回值组成一个数组，返回给p的回调函数；b. 只要p1,p2,p3中的任何一个被rejected，p的状态就会变成rejected，此时第一个被rejected的实例的返回值，会返回给p的回调函数。 var fs = require('fs') var read = function (filename){ var promise = new Promise(function(resolve, reject){ fs.readFile(filename, 'utf8', function(err, data){ if (err){ reject(err); } resolve(data); }) }); return promise; } var promises = [1, 2].map(function(fileno){ return read('./text' + fileno + '.txt'); }); Promise.all(promises) .then(function(contents){ console.log(contents); }) .catch(function(err){ console.log(\"error caught: \" + err); }) 上述代码中会并发执行读取text1.txt和text2.txt的操作，如果两个文件都读取成功的话，输出他们的内容，组成数组（contents）。 Tips：（1）Promise.race()也是将多个Promise实例包装成一个新的Promise实例（var p = Promise.race([p1,p2,p3])），上述代码中，p1、p2、p3只要有一个实例率先改变状态，p的状态就会跟着改变，那个率先改变的Promise实例的返回值，就传递给p的返回值。 （2）有时候需将现有对象转换成Promise对象，可以使用Promise.resolve()。 （3）Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。 Generator函数 Generator函数的函数名前面有一个*，Generator函数封装了一个异步任务，需要异步操作的地方，使用yield标注。yield语句表示，执行到此处执行权就交给其他协程，也就是说，yield是两个阶段的分界线。协程遇到yield语句就暂停执行，直到执行权返回，再从暂停处继续执行。这种写法的优点是，可以把异步代码写得像同步一样。 function* gen(x){ var y = yield x + 2; return y; } var g = gen(1); var r1 = g.next(); // { value: 3, done: false } console.log(r1); var r2 = g.next() // { value: undefined, done: true } console.log(r2); ES 7中的async和awaitasync和await是ES 7中的新语法，新到连ES 6都不支持，但是可以通过Babel一类的预编译器处理成ES 5的代码。目前比较一致的看法是async和await是js对异步的终极解决方案。 var fs = require('fs'); var readFile = function (fileName){ return new Promise(function (resolve, reject){ fs.readFile(fileName, function(error, data){ if (error){ reject(error); } else { resolve(data); } }); }); }; var asyncReadFile = async function (){ var f1 = await readFile('./text1.txt'); var f2 = await readFile('./text2.txt'); console.log(f1.toString()); console.log(f2.toString()); }; asyncReadFile();","path":"2019/03/18/article10/"},{"title":"http请求","text":"http请求老生常谈的http请求，简单来说就是几个步骤：域名解析-&gt;发起TCP的3次握手-&gt;建立TCP连接后发起http请求-&gt;服务器响应请求，浏览器得到代码-&gt;浏览器解析代码，并请求html代码中的资源（js、css等）-&gt;浏览器对页面进行渲染呈现给用户。 域名解析域名解析是通过我们输入的域名查找到对应的ip地址，一般来说，会通过以下几种方式查找对应的ip地址：1.浏览器会首先搜索浏览器自身的DNS缓存（缓存时间大概一分钟，存储1000条缓存），查询未果，进入下一步骤 2.浏览器没有查找到对应的条目时，浏览器会搜索操作系统的DNS缓存，没有找到，继续下一步骤 3.如果操作系统中也没找到，就会去读取host文件中是否有对应的ip地址，否则继续下一步骤 4.在host文件中没有查找到，浏览器会发起一个DNS系统调用，即向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器先查找自身的缓存，找到对应的条目，如果没有找到，运营商的DNS代我们的浏览器发起迭代DNS请求。 一般情况下，以上四个步骤就能找到，但是依旧没有找到，则会进入下面几个步骤： 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。 如果第5步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器） 如果第6步也没有查询成功，那么客户端就要进行广播查找 如果第7步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样） 如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。 三次握手拿到域名解析后的ip地址，User-Agent（一般指浏览器）会以一个随机端口向服务器的web程序80端口发起TCP连接请求。这个连接请求到达服务器端后，进入网卡，然后进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序（本文就以Nginx为例），最终建立了TCP/IP的连接。1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复 2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。 3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。 为什么HTTP协议要基于TCP来实现？ 目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。 建立TCP连接后发起http请求进过TCP3次握手之后，浏览器发起了http的请求（看第包），使用的http的方法 GET 方法，请求的URL是 / ,协议是HTTP/1.0 HTTP协议请求（request）和响应（response）报文分析请求报文：HTTP协议使用TCP协议进行传输，在应用层协议发起交互之前，首先是TCP的三次握手。完成了TCP三次握手后，客户端会向服务器发出一个请求报文。请求报文的格式如下图所示： （1）请求行中的method请求行的方法，我们常知的有POST、GET、DELETE这些，但是实际上，HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。下面简单介绍一下这些请求方式: GET请求：1.向特定资源发送请求，查询数据2.在客户端，GET方式在通过URL提交数据，数据在URL中可以看到3.对于GET方式，服务器端用Request.QueryString获取变量的值4.GET方式提交的数据不能大于2KB（主要是URL长度限制）5.由于使用GET时，参数直接显示在地址栏上，所以对于非敏感数据，可以使用GET请求 POST请求：1.向指定的资源，提交数据进行处理请求，有可能创建或修改已有数据2.POST方式，数据放在HTML HEADER内提交3.对于POST方式，服务器用Request.Form获取提交的数据4.POST对提交的数据大小没有限制5.相比于GET请求，POST请求更安全 HEAD请求1.HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体。一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。这种方法可以用来获取请求中隐含的元信息，而不用传输实体本身。也经常用来测试超链接的有效性、可用性和最近的修改。2.一个HEAD请求的响应可被缓存，也就是说，响应中的信息可能用来更新之前缓存的实体。如果当前实体跟缓存实体的阈值不同（可通过Content-Length、Content-MD5、ETag或Last-Modified的变化来表明），那么这个缓存就被视为过期了。 OPTIONS预请求1.OPTIONS是浏览器对复杂跨域请求的一种处理方式，在真正请求之前，进行一次预请求，即参数OPTIONS的第一次请求，用于试探服务器的响应是否正确，如果OPTIONS请求之后的响应是拒绝的，那么就会停止第二次请求。2.OPTIONS请求产生的情况有三种：（1）请求的方式不是GET/HEAD/POST，（2）POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain，（3）请求设置了自定义的header字段 PUT请求与GET不同的是，PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。 DELETE请求请求服务器删除Request-URI所标识的资源 TRACE请求回显服务器收到的请求，主要用于测试或诊断 CONNECT请求HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 （2）请求首部 Accept：请求的对象类型。如果是“/”表示任意类型，如果是指定的类型，则会变成“type/”。 Accept-Language：使用的语言种类。 Accept-Encording：页面编码种类。 Accept-Charset：页面字符集。说到这里，需要解释以下字符集和编码的区别。字符集通常对应着一种语言，将语言中的所有字符集合起来就可以视为一种字符集，这样我们可以看出，中文并非是一种字符集，因为中文无法使用一些字符来进行表示；而编码则是将字符转换为计算机所能识别的2进制数的一种方式，例如常说的unicode，UTF-8，ANSI等等，我们在访问一些国外网站会出现乱码的原因就是因为我们浏览器所使用的编码与页面所使用的编码不能互相识别。我们常说的BIG5和GB2312都是编码。 User-Agent：提供了客户端浏览器的类型和版本。 Host：连接的目标主机，如果连接的服务器是非标准端口，在这里会出现使用的非标准端口。 Connection：对于HTTP连接的处理，keep-alive表示保持连接，如果是在响应报文中发送页面完毕就会关闭连接，状态变为close。 响应报文当收到get或post等方法发来的请求后，服务器就要对报文进行响应。状态行给出了服务器的http版本，以及一个响应代码。响应代码是服务器根据请求进行查找后得到的结果的一种反馈，共有5大类。分别以1、2、3、4、5开头。1**表示接收到请求，继续进程，在发送post后可以收到该应答。 2**表示请求的操作成功，在发送get后返回。 3**表示重发，为了完成操作必须进一步动作。 4**表示客户端出现错误。 5**表示服务器出现错误。 其余部分称为应答实体。","path":"2019/03/18/article9/"},{"title":"地图导出","text":"前言gis开发侧重于专业知识，相比于其他的前端开发领域，gis功能开发的资料相对较少，我会根据自己的日常项目和学习逐一进行整理，丰富开发资料。由于esri提供的api是用dojo框架开发的，所以在我的博客里涉及到gis开发例子的将是使用dojo语法。今天要给大家介绍一下地图导出模块核心代码。 导出地图需要以下参数：center（地图中心）、scale（导出地图比例尺）、WMTSLayers（WMTS图层）、ArcLayers（arcMap图层）、dpi（像素）、width（地图宽度）、height（地图高度）、extent（当前地图显示范围）、proxyUrl(代理地址)。根据上面的参数，我们需要封装一个ExportMapImg类，包含初始化地图、加载图层、初始化图层导出坐标系、打印几个方法。 具体实现初始化地图我们创建一个容器存放当前的地图，并顺利获取地图的空间范围、中心、比例尺等属性。 _initMap: function () { $('body').append($('&lt;div id=\"' + this.mapId + '\" style=\"height:' + this.option.height + 'px;width:' + this.option.width + 'px;z-index:-12;position:absolute;\">&lt;/div>')); this.map = new map(this.mapId, { logo: false, slider: false }); this.map.extent = this.option.extent; var defs = []; if (this.option.center) { defs.push(this.map.centerAt(this.option.center)); } if (this.option.scale) { defs.push(this.map.setScale(this.option.scale)); } all(defs).then(lang.hitch(this,this._addLayers)); } 地图创建好了以后，添加图层。常用的图层服务分为WMTS、dynamic、tiled三种。WMTS是Web地图切片服务,dynamic是动态地图服务，tiled是地图瓦片服务。不同类型的地图服务的加载方法不一样，ersi的开发者文档中有详细的例子可以参照。在我们这个例子中，添加图层是用于map的初始化，所以WMTS图层全部添加，而arcgis图层则只添加一个图层。 _addLayers: function () { var defs = []; if (this.option.WMTSLayers.length) {//保证行列号完全正确，所有wmts图层都添加 defs = this.option.WMTSLayers.map(function (item) { var def = new Deferred(); item.on('update-end', function () { def.resolve(); }); this.map.addLayer(item); return def; }, this); } if (!this.option.WMTSLayers.length &amp;&amp; this.option.ArcLayers.length) {//当未添加wmts图层时，只添加一个图层用于map初始化 var def = new Deferred(); var layerItem = this.option.ArcLayers[0]; var layer = new ArcGISDynamicMapServiceLayer(layerItem.url); layer.setVisibleLayers(layerItem.visibleLayers); layer.on('load', function () { def.resolve(); }); this.map.addLayer(layer); defs.push(def); } if (this.option.graphics.length) { var graLayer = new GraphicsLayer(); this.map.addLayer(graLayer); this.option.graphics.map(function (gra) { if (!gra.symbol) { gra.setSymbol(this._getSymbol(gra.geometry.type)); } graLayer.add(new Graphic(gra.geometry, gra.symbol)); }, this); } all(defs).then(lang.hitch(this, this._print)); }, 地图导出相对来说比较复杂，因为要将地图服务生成图片，这里我选择的是将arcgis图层使用export接口输出为png图片，并转为base64；将WMTS图层的瓦片转为base64。 /** *ArcGis 图层全部使用export接口输出png图片，并转换为base64 * @returns {Deferred} * @private */ _getExportPngs: function () { var pngsDef = new Deferred(); var $pngRoot = $('&lt;div style=\"width: 100%;height: 100%;position: absolute;\">&lt;/div>'); var defs = this.option.ArcLayers.map(function (item) { return this._exportPng(item.url, this.map.extent, this.option.dpi, this.option.height, this.option.width, item.visibleLayers, this.option.innerSR, this.option.outSR); }, this); all(defs).then(lang.hitch(this, function (results) { results.map(function (img) { $pngRoot.append($('&lt;img alt=\"\" style=\"width: 100%;height: 100%;position: inherit;\" src=\"' + img + '\">')); }); pngsDef.resolve($pngRoot); })); return pngsDef; }, /** * 将wmts图层的瓦片转为base64,并返回瓦片位置变换后的div节点 * @returns {Deferred} * @private */ _getTileLayerImgs: function () { var layersDef = new Deferred(); var scale = this.map.getScale(); var rect = this.map.__visibleRect; var $layersRoot = $('&lt;div>&lt;/div>'); var layerTileStr = 'position:absolute;border:none;margin:0;padding:0;visibility:inherit;'; var layerDivStr = 'position:absolute;overflow:visible;transition:-webkit-transform 500ms ease 0s;'; var tileLayersStr = 'position:absolute;overflow:visible;display:block;'; var layerDefs = []; this.option.WMTSLayers.map(function (item) {//图层 var layer = this.map._layers[item.id]; if (scale &lt; layer.maxScale &amp;&amp; scale > layer.minScale) return; var layerDef = new Deferred(); var $root = $('&lt;div style=\"height: ' + rect.height + 'px;width: ' + rect.width + 'px;' + 'transform: translate(' + layer.__coords_dx + 'px,' + layer.__coords_dy + 'px);' + tileLayersStr + '\">&lt;/div>'); var $layer = $('&lt;div style=\"height: ' + rect.height + 'px;width: ' + rect.width + 'px;' + layerDivStr + '\">&lt;/div>'); var tiles = layer._tileIds; var tileBs = layer._tileBounds; var tileImgs = layer._tiles; var defs = tiles.map(function (id) {//瓦片 var tileItem = tileBs[id]; var def = new Deferred(); var imgSrc = (this.option.proxyUrl === '' ? '' : this.option.proxyUrl + '?') + tileImgs[id].src; // console.log(imgSrc); this._getImgBase64(imgSrc, 'png', tileItem.height, tileItem.width).then( lang.hitch(this, function (url) { $layer.append($('&lt;img style=\"height: ' + tileItem.height + 'px;width: ' + tileItem.width + 'px;' + 'transform: translate(' + tileItem.x + 'px,' + tileItem.y + 'px);' + layerTileStr + '\" src=\"' + url + '\">')); def.resolve(); }) ); return def; }, this); $root.append($layer); all(defs).then(lang.hitch(this, function () { layerDef.resolve($root); })); layerDefs.push(layerDef); }, this); all(layerDefs).then(lang.hitch(this, function ($layers) { $layersRoot.append($layers); layersDef.resolve($layersRoot); })); return layersDef; }","path":"2019/03/18/article8/"},{"title":"关于微信登录","text":"前言做微信小程序也有小一个月了，整体来说，做的比较顺利，没有遇到特别难搞的坑，这里还是得感谢腾讯为开发者提供资料齐全的开发文档。想速度上手微信小程序的小伙伴们，戳这里，微信小程序开发者文档 微信小程序开发中，我们常常需要获取用户信息，我写小程序时是1月份，开始我并不知道接口已经做了调整，然后就直接使用button去获取用户信息，然而，调试时，出现以下提示。 具体实现当我去官方文档上查阅获取用户信息接口时，发现其已经做了一些的调整。相信大家都知道，我们在第一次使用某个小程序时会弹出一个授权框，询问用户是否允许获取用户信息。如今接口调整为在用户未授权过的情况下调用此接口，将不再出现授权弹窗，会直接进入 fail 回调。在用户已授权的情况下调用此接口，可成功获取用户信息。 竟然不再出现授权窗口了，那我们就需要使用button进行引导。 &lt;button class='wexin-login' open-type=\"getUserInfo\" lang=\"zh_CN\" bindgetuserinfo=\"onGotUserInfo\"> &lt;image class='wexin-icon' src='/assets/images/content/share_wechat.png' /> &lt;text class='wexin-text' open-type=\"getUserInfo\" bindgetuserinfo=\"onGotUserInfo\" lang=\"zh_CN\">微信登录&lt;/text> &lt;/button> 逻辑部分处理为: getWXCode: function() { var that = this; wx.login({ success: function(res) { api.post('/edu/user/WechatAPPLogin', { encryptedData: that.data.userInfo.encryptedData, iv: that.data.userInfo.iv, code: res.code }, function(res) { that.onBack() getApp().globalData.userId = res.content.userInfo.id }.bind(this), function(res) { wx.showToast({ title: res.msg, icon: 'none', duration: 2000 }) }) } }) }","path":"2019/03/17/article7/"},{"title":"制作一个添加工作经验的功能","text":"前言前几天给一个app做项目经验添加功能时，自己犯了几个错误，于是决定总结一下，算是写成一个demo，给大家参考一下吧。 具体实现 添加工作经验的页面如图1，这是一个用户的详情页面，每条工作经验的右上角，添加了删除按钮，区域的下方有继续添加经历的按钮。说白了，这个功能就是实现对表单数据的增、删、改功能。首先，我从后端接口中获取到用户的工作经验数据（也可能是一个空数组），这块的逻辑我们很容易写出来，就是根据获取到的值进行遍历即可。 &lt;div v-for=\"(item, index) in experiences\" :key=\"item.id\"> &lt;div class=\"detail\"> &lt;image class=\"closeIcon\" :src=\"iconPath('icon_gb_small')\" @click=\"removeExperience(item.id)\">&lt;/image> &lt;text class=\"unselect-txt\">开始时间&lt;/text> &lt;input class=\"input\" type=\"date\" v-model=\"item.startDate\">&lt;/input> &lt;image class=\"icon\" :src=\"iconPath('icon_pen')\">&lt;/image> &lt;/div> &lt;div class=\"detail\"> &lt;text class=\"unselect-txt\">结束时间&lt;/text> &lt;input class=\"input\" type=\"date\" v-model=\"item.endDate\">&lt;/input> &lt;image class=\"icon\" :src=\"iconPath('icon_pen')\">&lt;/image> &lt;/div> &lt;div class=\"detail2\"> &lt;text class=\"unselect-txt\">从业说明：&lt;/text> &lt;textarea v-model=\"item.introduction\" class=\"textarea\">&lt;/textarea> &lt;/div> &lt;div class=\"list-gap\">&lt;/div> &lt;/div> &lt;div> &lt;div class=\"next-btn\" @click=\"addNextExperience\"> &lt;text class=\"next-button\">继续添加经历&lt;/text> &lt;/div> &lt;/div> &lt;div class=\"btn\" @click=\"addUserMaterial\"> &lt;text style=\"font-size: 28px;color: #ffffff;\">完成&lt;/text> &lt;/div> 我们在input和textarea中使用v-model进行数据的双向绑定。我们都知道，vue实现了一套虚拟的DOM，我们不需要直接操作DOM元素，只需要操作数据就可重新渲染页面。而背后的原理得益于高效的Diff算法，具体的原理我不在这阐述。key的作用是为了高效的更新虚拟DOM。所以为了让vue可以区分他们，我们在做循环或相同标签元素的过渡切换时，都有必要使用到key属性，所以在上述循环中我们指定项目经验的id为key值。下面我们开始写新增事件和删除事件。新增 addNextExperience() { this.experienceId++ this.experiences.push({id: this.experienceId, startDate: '', endDate: '', introduction: ''}) } 删除 removeExperience(index) { this.experiences = this.experiences.filter(function (experience) { return (index !== experience.id); }) } 新增事件我使用了一个全局变量experienceId为id赋值，这个experienceId的值为多少合适呢。我们上面通过接口拿到了当前用户的工作经验值，每条工作经验都有一个id号，我首先想到的就是，在我新增时，这个id号的起始值应该为当前用户的工作经验的id号的最大值+1，这样做的原因是为了保证从后端接口取出的id号和我任意一条新增数据的id号都不会相同，这样一来，每一条工作经验的id号才不会出现重复的情况。","path":"2019/03/17/article6/"},{"title":"ES6常用总结","text":"文章参考来源:[ECMAScript 6 入门] 阮一峰的文档讲的比较的详细，我当时在看的时候，也是没有太多的耐心，加上没有实战的话，忘的很快，所以决定根据每个章节，抽离出重要的知识点，将es6整个过一遍，文章中的示例均来源于文档。 一、let和const let：申明一个变量，所申明的变量只在let命令所载代码块内有效。（1）循环中使用，循环体外引用报错 for (let i = 0; i &lt; 10; i++) { } console.log(i); // ReferenceError: i is not defined （2）不存在变量提升，即必须声明后才可以使用 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; （3）暂时性死区，作用域内存在let命令后，所声明的变量就绑定在该区域内，不再受外界的影响 var tmp = 123; if (true) { tmp = 'abc'; // ReferenceError let tmp; } （4）不允许重复声明 // 报错 function func() { let a = 10; var a = 1; } // 报错 function func() { let a = 10; let a = 1; } const：声明一个只读常数，一旦声明，常量的值不可改变（1）只声明，不赋值，变量报错，与let一致，const只在声明所在的块级作用域内有效。 const foo; // SyntaxError: Missing initializer in const declaration if (true) { const MAX = 5; } MAX // Uncaught ReferenceError: MAX is not defined （2）和let一致，也存在暂存性死区（3）const保证变量指向的内存地址所保存的值不变，所以对于变量为数值、字符串、布尔值这样的简单数据类型，值直接保存在变量所指向的内存地址中，因此直接等于常量。但对于复合型数据，如对象和数组，变量指向但是内存地址，保存但是一个指向实际数据的指针，const只能保证这个指针是固定的，而它指向的数据结构是否可变是不可控制的。 const foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 foo.prop = 235; foo.prop // 235 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: \"foo\" is read-only 二、变量的解构赋值 数组的解构赋值（1）解构不成功，变量的值变为undefined。不完全匹配的情况下，解构依然成功。 let [a, b, c] = [1, 2, 3]; let [foo, [[bar], baz]] = [1, [[2], 3]]; // foo:1,bar:2,baz:3 let [head, ...tail] = [1, 2, 3, 4]; // head:1,tail:[2,3,4] let [x, y, ...z] = ['a']; // x:'a',y:undefined,z:[] let [x, y] = [1, 2, 3]; // x:1,y:2 （2）等号右边为不可遍历的解构，解构报错 // 报错 let [foo] = 1; let [foo] = false; let [foo] = NaN; let [foo] = undefined; let [foo] = null; let [foo] = {}; （3）对于 Set 结构，也可以使用数组的解构赋值 let [x, y, z] = new Set(['a', 'b', 'c']); x // \"a\" （4）指定默认值，指定默认值时，如果数组成员是null，默认值不会生效，因为null不严格等于undefined。如果默认值是一个表达式时，这个表达式是惰性的，即只有用到时，才会进行求值。 let [foo = true] = []; foo // true let [x, y = 'b'] = ['a']; // x='a', y='b' let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' let [x = 1] = [undefined]; x // 1 let [x = 1] = [null]; x // null function f() { console.log('aaa'); } let [x = f()] = [1]; x // 1 （5）默认值可以引用解构赋值的其他变量，但是该变量必须已经声明 let [x = 1, y = x] = []; // x=1; y=1 let [x = 1, y = x] = [2]; // x=2; y=2 let [x = 1, y = x] = [1, 2]; // x=1; y=2 let [x = y, y = 1] = []; // ReferenceError: y is not defined 对象的解构赋值（1）对象解构不需要按顺序来取值，变量与属性名相同，即可取到值，解构失败，变量的值等于undefined let { bar, foo } = { foo: 'aaa', bar: 'bbb' }; foo // \"aaa\" bar // \"bbb\" let { baz } = { foo: 'aaa', bar: 'bbb' }; baz // undefined （2）对象解构也可以用于嵌套结构的对象 let obj = { p: [ 'Hello', { y: 'World' } ] }; let { p: [x, { y }] } = obj; x // \"Hello\" y // \"World\" （3）如果解构模式是嵌套的对象，而子对象的父属性不存在，将会报错 // 报错 let {foo: {bar}} = {baz: 'baz'}; （4）对象的解构赋值可以取到继承的属性 const obj1 = {}; const obj2 = { foo: 'bar' }; Object.setPrototypeOf(obj1, obj2); const { foo } = obj1; foo // \"bar\" （5）对象的解构也可以指定默认值，默认值生效的条件是，对象的属性严格等于undefined var {x = 3} = {x: undefined}; x // 3 var {x = 3} = {x: null}; x // null （6）对数组进行对象属性解构 let arr = [1, 2, 3]; let {0 : first, [arr.length - 1] : last} = arr; first // 1 last // 3 字符串解构赋值 const [a, b, c, d, e] = 'hello'; a // \"h\" b // \"e\" c // \"l\" d // \"l\" e // \"o\" let {length : len} = 'hello'; len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象，由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 let {toString: s} = 123; s === Number.prototype.toString // true let { prop: x } = undefined; // TypeError let { prop: y } = null; // TypeError *函数参数解构赋值 [[1, 2], [3, 4]].map(([a, b]) => a + b); // [ 3, 7 ] 函数参数的解构也可以使用默认值，如果解构失败，参数值等于默认值，如果参数是一个对象，对这个对象进行解构，得到参数的值 function move({x, y} = { x: 0, y: 0 }) { return [x, y]; } move({x: 3, y: 8}); // [3, 8] move({x: 3}); // [3, undefined] move({}); // [undefined, undefined] move(); // [0, 0] // undefined就会触发函数参数的默认值 [1, undefined, 3].map((x = 'yes') => x); // [ 1, 'yes', 3 ] 不能使用圆括号（1）变量声明语句 // 全部报错 let [(a)] = [1]; let {x: (c)} = {}; let ({x: c}) = {}; let {(x: c)} = {}; let {(x): c} = {}; let { o: ({ p: p }) } = { o: { p: 2 } }; （2）函数参数声明 // 报错 function f([(z)]) { return z; } // 报错 function f([z,(x)]) { return x; } （3）赋值语句模式 // 全部报错 ({ p: a }) = { p: 42 }; ([a]) = [5]; [({ p: a }), { x: c }] = [{}, {}]; 可使用圆括号赋值语句非模式部分，可使用圆括号 [(b)] = [3]; // 正确 ({ p: (d) } = {}); // 正确 [(parseInt.prop)] = [3]; // 正确 三、Set和Map数据结构 set：set数据结构类似于数组，但是成员的值是唯一的，没有重复值；set本身是一个构造函数，用来生成set数据结构 （1）去除数组重复成员 const set = new Set([1, 2, 3, 4, 4]); [...set] // [1, 2, 3, 4] （2）set四个方法 add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 （3）Array.from方法可以将 Set 结构转为数组 function dedupe(array) { return Array.from(new Set(array)); } dedupe([1, 1, 2, 3]) // [1, 2, 3] （4）遍历操作，set结构没有键名，只有键值，所以keys和values方法得到的值是相同的 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 let set = new Set(['red', 'green', 'blue']); for (let item of set.keys()) { console.log(item); } // red // green // blue for (let item of set.values()) { console.log(item); } // red // green // blue for (let item of set.entries()) { console.log(item); } // [\"red\", \"red\"] // [\"green\", \"green\"] // [\"blue\", \"blue\"] （5）数组的map和filter方法用于 Set let a = new Set([1, 2, 3]); let b = new Set([4, 3, 2]); // 并集 let union = new Set([...a, ...b]); // Set {1, 2, 3, 4} // 交集 let intersect = new Set([...a].filter(x => b.has(x))); // set {2, 3} // 差集 let difference = new Set([...a].filter(x => !b.has(x))); // Set {1} WeakSet（1）WeakSet的成员只能是对象，不能是任何其他类型的值（2）WeakSet中的对象是弱引用，如果其他对象不再引用该对象，则垃圾回收机制会自动将该变量所占的内存进行回收，所以WeakSet只适合临时存储对象。WeakSet中对象拥有数量多少个，取决于垃圾回收机制什么时候运行，所以WeakSet的对象个数是不确定的，所以WeakSet不能进行遍历。（3）WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构 Map（1）类似数组，键值对的集合，键的范围不局限于字符串，各种类型的值都可以做键。（2）Map如果对同一个键多次赋值，后面的值将覆盖前面的值 四、Promise 对象Promise 是一种异步编程的解决方案。（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fullfilled（已成功）和rejected（已失败）（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。对象状态的改变只能从pending到fullfilled或pending 到rejected。一旦情况发生了，其状态就已凝固，不会再发生改变。","path":"2019/03/16/article5/"},{"title":"正则表达式化整为零","text":"前言写代码也有一段时间了，正则表达式是经常会用得到，每次遇到一些匹配时，就上网找，因为自己一直都在排斥学正则表达式，但是拖着不是程序猿的好习惯，那今天就来好好整理下。不求全部学会，只求见到认识。正则表达式常用的几种操作方法有：match、search、split、findall、sub、replace。 基本字符特殊字符特殊字符就是具有特殊含义的字符。在正则表达式中，这些特殊字符匹配的意义各有不同，如果需要在字符串中查找这些特殊符号，就需要在其前面加一个\\进行转义。 特殊字符 含义 $ 匹配输入字符串的结尾 （） 标记一个子表达的开始和结束位置 * 匹配前面的表达式零次或多次 + 匹配前面的子表达式一次或多次 . 匹配除换行符\\n 之外的任何单字符 [ 标记一个中括号表达式的开始 ？ 匹配前面的子表达式零次或一次 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合 { 标记限定符表达式的开始 指明两项之间的一个选择 贪婪和非贪婪 在上表中列举的*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 定位符定位符用来描述字符串或单词的边界，其中^和$分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B表示非单词边界。 Tip：不能将限定符和定位符一起使用。 带反斜杠的元字符普通字符前加反斜杠还是普通字符，但是有些字符加上反斜杠之后就会变成元字符 语法1.检索字符我们既可以检索普通字符也可以检索表情符号，因为表情符其实也是一个字符，使用match方法可以返回一个数组，包含检索字符内容，被检索到到索引号。 'hello world'.match(/w/); > [\"w\", index: 6, input: \"hello world\", groups: undefined] 'hello 😀world'.match(/😀/); > [\"😀\", index: 6, input: \"hello 😀world\", groups: undefined] 2.匹配文本开始和结束我们用^匹配文本的开始，用$匹配文本的结束。匹配文本的第一个字符时，必须是匹配文本的第一个字符，否则匹配不成功。 'hello'.match(/^h/); > [\"h\", index: 0, input: \"hello\", groups: undefined] 'hello'.match(/a^h/); > null 'hello'.match(/o$/); > [\"o\", index: 4, input: \"hello\", groups: undefined] 3.元字符 元字符 含义 \\b 匹配一个单词边界 \\B 匹配一个非单词边界 \\d 匹配一个数字字符 \\D 匹配一个非数字字符 \\s 匹配一个空白字符 \\S 匹配一个非空白字符 \\w 匹配一个字母或一个数字或一个下划线 \\W 匹配一个字母、数字和下划线之外的字符 元字符上述表格中已列举出来了，元字符的大写相当于取反。匹配单词边界的对中文边界是无效的。 // \\b 匹配单词边界 'hello world'.match(/\\bworld$/); > [\"world\", index: 6, input: \"hello world\", groups: undefined] '你 好'.match(/\\B好$/); [\"好\", index: 2, input: \"你 好\", groups: undefined] // \\d 匹配数字边界 '123'.match(/\\d2/); [\"12\", index: 0, input: \"123\", groups: undefined] // \\s匹配单个空白字符 'a b'.match(/\\s/); [\" \", index: 1, input: \"a b\", groups: undefined] // \\w匹配单个字母数字下划线 'a b'.match(/\\w/); [\"a\", index: 0, input: \"a b\", groups: undefined] 4.量词限定符用来指定正则表达式的一个给定组件必须要出现多次才能匹配 字符 描述 * 匹配前面的子表达式零次或多次 + 匹配前面的子表达式一次或多次 ？ 匹配前面的子表达式零次或一次 {n} n是一个非负整数。匹配确定的n次 {n,} 至少匹配n次 {n,m} n&lt;=m，最少匹配n次最多匹配m次 // 非贪婪模式 'https'.match(/http(s)?/); [\"https\", \"s\", index: 0, input: \"https\", groups: undefined] 'gooooogle'.match(/go{2,5}gle/); [\"gooooogle\", index: 0, input: \"gooooogle\", groups: undefined] 5.字符组方括号在正则中表示一个区间,我们称之为字符组。 'grey or gray'.match(/gr[ae]y/); [\"grey\", index: 0, input: \"grey or gray\", groups: undefined] 6.捕获组和非捕获组[ES2018]圆括号的意思是将它其中的字符集合打包成一个整体,然后量词就可以操作这个整体了。 'i love you very very very much'.match(/i love you (very )+much/); [\"i love you very very very much\", \"very \", index: 0, input: \"i love you very very very much\", groups: undefined] 7.正则内捕获正则内捕获使用\\数字的形式根据对应前面的圆括号捕获内容，这种捕获的引用也称为反向引用。 '&lt;span>hello world&lt;/span>'.match(/&lt;([a-zA-Z]+)>.*&lt;\\/\\1>/); > [\"&lt;span>hello world&lt;/span>\", \"span\", index: 0, input: \"&lt;span>hello world&lt;/span>\", groups: undefined] 8.正则外捕获 'hello **world**'.replace(/\\*{2}(.*)\\*{2}/, '&lt;strong>$1&lt;/strong>'); \"hello &lt;strong>world&lt;/strong>\" 9.非捕获组当我们需要匹配捕获组,但是又不需要捕获组结果时,我们可以使用非捕获组(?:pattern) 'industry'.match(/industr(?:y|ies)/); [\"industry\", index: 0, input: \"industry\", groups: undefined] 10.或 'aA'.match(/a|A/); [\"a\", index: 0, input: \"aA\", groups: undefined] 11.零宽断言零宽断言零宽：匹配一个位置，本身没有宽度；断言：断言之前或者之后应该有什么或没有什么（1）零宽肯定先行断言(?=)[正向肯定预查] 'TypeScript JavaScript javascript'.match(/\\b\\w{4}(?=Script\\b)/); [\"Type\", index: 0, input: \"TypeScript JavaScript javascript\", groups: undefined] （2）零宽肯定后行断言(?&lt;=)[ES2018] [反向肯定预查] '演员高圆圆 将军霍去病 演员霍思燕'.match(/(?&lt;=演员)霍\\S+/); [\"霍思燕\", index: 14, input: \"演员高圆圆 将军霍去病 演员霍思燕\", groups: undefined] （3）零宽否定先行断言(?!)[正向否定预查]否定就是没有,就是要求一段文本,后面一定不要紧跟一段指定文本 'TypeScript Perl JavaScript'.match(/\\b\\w{4}(?!Script\\b)/); [\"Perl\", index: 11, input: \"TypeScript Perl JavaScript\", groups: undefined] （4）零宽否定后行断言(?&lt;!)[ES2018] [反向否定预查]要求一段文本,前面一定不跟某一段指定文本 '演员高圆圆 将军霍去病 演员霍思燕'.match(/(?&lt;!演员)霍\\S+/); [\"霍去病\", index: 8, input: \"演员高圆圆 将军霍去病 演员霍思燕\", groups: undefined] 12.修饰符（1）g修饰符(global) 默认情况下,正则从左向右匹配,只要匹配到结果就会结束,g修饰符会开启全局匹配模式,找到所有的匹配结果（2）i修饰符(ignoreCase)默认情况话,正则是区分大小写的,i修饰符的作用是可以全局忽略大小写.（3）m修饰符(multiline)默认情况下，^和$匹配的是文本的开始和结束，加上m修饰符，它们的含义就变成了多行的行首和行尾,支持多行搜索（4）y修饰符(sticky粘连)[ES6]y修饰符有和g修饰符重合的功能，它们都是全局匹配,不同在于,g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义 'a bag with a tag has a mag'.match(/\\wag/g); [\"bag\", \"tag\", \"mag\"] 'a bag with a tag has a mag'.match(/\\wag/y); null 'bagtagmag'.match(/\\wag/y); [\"bag\", index: 0, input: \"bagtagmag\", groups: undefined] 'bagtagmag'.match(/\\wag/gy); [\"bag\", \"tag\", \"mag\"] （5）s修饰符(singleline)[ES2018]s修饰符的作用是让.可以匹配任意单个字符。（6）u修饰符(unicode)[ES6]有些Unicode字符超过一个字节,正则无法正确识别,可用u修饰符来处理。 ES6变化ES6中,将字符串的4个正则方法(match,replace,search,split)在语言内部全部调用RegExp的实例方法,从而做到所有与正则相关的方法,全部定义在RegExp对象上。","path":"2019/03/15/article4/"},{"title":"JavaScript内存优化","text":"内存泄漏当程序持续无法释放其使用的临时内存时就会发生内存泄漏。JavaScript提供GC垃圾回收进行自动内存管理，其机制是找出不再使用的变量，释放其占用的内存，但是这个内存不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 不再使用的变量就是生命周期结束的变量，即局部变量（全局变量的生命周期直到浏览器卸载才会结束）。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束。闭包中由于内部函数的原因，外部函数并不能算是结束。 避免内存泄漏(1)避免DOM节点创建中闪屏IE中有一类典型的内存泄漏模式称为DOM插入顺序内存泄漏。当创建动态当DOM节点时，我们确保上层元素首先被附着，然后是底层。如果顺序反过来，可能导致内存泄漏。当要创建的 DOM 树很大时，这种从上而下的创建 DOM 节点的方式可能会造成浏览器视图的闪烁。一个好的办法是在 DOM 树渲染期间通过样式”display:none”把最顶层父节点隐藏起来，直到整个 DOM 树都创建好之后，再把顶层父节点展现出来。 var frameNode = domCon.create('div', { \"style\": {display: \"none\"} }, this.domNode); // 创建 frameNode 节点下的子节点树 // 当子节点树创建好之后，显示整个 frameNode 节点树 domStyle.set(frameNode, \"display\",'block') (2)DOM节点循环引用当Javascript对象引用DOM元素并且DOM元素当属性引用Javascript对象时，循环应用发生并导致DOM节点泄漏。 var obj = document.getElementById(\"id\"); document.getElementById(\"id\").expandoProperty = obj; 若需要这么使用，在准备移除节点时，先将元素expandoProperty属性设置为null。 (3)Dom节点的引用 &lt;html> &lt;body> &lt;div id=\"refA\"> &lt;ul> &lt;li>&lt;a>&lt;/a>&lt;/li> &lt;li>&lt;a>&lt;/a>&lt;/li> &lt;li>&lt;a id=\"refB\">&lt;/a>&lt;/li> &lt;/ul> &lt;/div> &lt;/body> &lt;/html> &lt;script> var refA = document.getElementById('refA'); var refB = document.getElementById('refB'); refB=null; refB引用了refA。它们之间是dom树父节点和子节点的关系。如果在此时移除refA,或者将refA对象设置为null，那么这个dom节点在浏览器内存中依然存在。因为refB对refA存在引用，所以除非在把refB释放，否则dom节点内存会一直存在浏览器中无法被回收掉。(4)闭包 window.onload = function() { var obj = document.getElementById(\"element\"); // this creates a closure over \"element\" // and will leak if not handled properly. obj.onclick = function(evt) { alert(\"leak the element DIV\"); }; }; 应用程序之后删除了element节点，JavaScript 引用仍然会持有孤立节点。这个孤立节点将会造成内存泄露。(5)定时器setTimeout setInterval当不需要setInterval或者setTimeout时，定时器没有被clear，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏。 ChromeDevTools工具以上介绍了几种内存泄漏的情况，那么我们在项目中如何发现可能存在内存泄漏的地方。 PerformancePerformance按时间顺序展示页面加载过程及后续过程的网络请求、页面渲染过程、JS运行时长、页面帧率、CPU/GPU使用情况等1，在timeline中观测页面资源加载情况（时长，顺序），降低页面加载时长。2，在timeline中观测FPS情况，观测底下的JS执行耗时，能分析出哪部分耗时过长，导致帧率下降 Memory Memory监控CPU使用情况，内存分配情况等，用于做深入分析 1、Record Allocation profiles(allocation sampling)监控函数执行期花费的时间。点击下方的Start按钮（也可以点击左边的黑色圆圈），这时候Chrome会开始记录网页的方法执行，然后我们点击界面的按钮来执行。（用来查看分配给各函数的内存大小）最后再点击右边区域的Stop按钮（或者左边的红色圆圈），这时监控就结束了。左边Profiles会列出一个文件，单击可以看到如下界面从上面结果中，可以发现，在点击开始，运行操作界面之后，点击停止，该工具记录了在这个期间，执行过的一些函数，以及执行这些函数所分配的内存状况。可以转换chart图表模式查看。2、Record Allocation timeline它的作用是为我们拍下一系列的快照（频率为50ms），为我们检测在启用它的时候每个对象的生存情况。形象一点说就是假如拍摄内存快照的功能是照相那么它功能相当于录像。当启用start按钮的时候它便开始录像，直到结束。左侧区域上半部分有一些蓝色和灰色的柱条。灰色的表示监控这段时间内活跃过的对象，但是被回收掉了。蓝色的表示依旧没有没回收.（用来查看实时的内存分配及回收情况）。3、Heap snapshotSummary(概要)视图能帮你通过构造函数分组寻找对象(和对象的内存使用)。该视图对找出DOM内存泄漏很有帮助。Comparison(对照)视图能够通过显示哪些对象内存被正确的回收了来搜寻内存泄漏。通常在一个操作前后记录两个(或更多)的内存使用快照。它是通过察看释放的内存和引用数目的差导来察看是否有内存泄漏，并找到原因。Constructor(构造函数)表示所有通过该构造函数生成的对象 Distance 对象到达GC根的最短距离 Shallow size 对应构造函数生成的对象的shallow sizes(直接占用内存) Retained size 展示了对应对象所占用的最大内存。 function a() { var obj = [1,2,.......n]; return function() { //js作用域的原因，在此闭包运行的上下文中可以访问到obj这个对象 console.log(obj); } } var b = a(); 正常情况下，a函数执行完毕 obj占用的内存会被回收，但是此处a函数返回了一个函数表达式，其中obj因为js的作用域的特殊性一直存在，所以我们可以说b引用了obj。每次访问b对象的时候都可以访问到obj，说明内存未被回收 所以对于obj来说直接占用内存[1,2,….n], 而b依赖obj，所obj是b的最大内存。","path":"2019/03/15/article3/"},{"title":"多坐标系下地图面积测量","text":"关于坐标系说到坐标系，作为一个地理信息系统专业的学生，我也一度比较的糊涂，今天，既然要做这样一个需求，那正好趁这个机会把坐标系这块整理一下。我们常用的坐标系有：2000中国大地坐标系（CGCS2000）、1980西安坐标系、1954北京坐标系统、WGS84坐标系（GPS数据所采用的坐标系统），在编程中也会遇到不同坐标系、不同的投影方式、不同的投影分带，需要进行转换、投影等，所以有必要认识一下WKID。 wkidWKID的英文全称是Well Known ID，即众所周知的编号，下面列举我国常用的地理和投影坐标系的WKID： 类别 wkid 坐标 地理坐标 4214 GCS_Beijing_1954 地理坐标 4326 GCS_WGS_1984 地理坐标 4490 GCS_China_Geodetic_Coordinate_System_2000 地理坐标 4555 GCS_New_Beijing 地理坐标 4610 GCS_Xian_1980 投影坐标 2327 Xian_1980_GK_Zone_13 投影坐标 2328 Xian_1980_GK_Zone_14 投影坐标 2329 Xian_1980_GK_Zone_15 投影坐标 2330 Xian_1980_GK_Zone_16 投影坐标 2331 Xian_1980_GK_Zone_17 投影坐标 2332 Xian_1980_GK_Zone_18 投影坐标 2333 Xian_1980_GK_Zone_19 投影坐标 2334 Xian_1980_GK_Zone_20 投影坐标 2335 Xian_1980_GK_Zone_21 投影坐标 2336 Xian_1980_GK_Zone_22 投影坐标 2337 Xian_1980_GK_Zone_23 投影坐标 2338 Xian_1980_GK_CM_75E 投影坐标 2339 Xian_1980_GK_CM_81E 投影坐标 2340 Xian_1980_GK_CM_87E 投影坐标 2341 Xian_1980_GK_CM_93E 投影坐标 2342 Xian_1980_GK_CM_99E 投影坐标 2343 Xian_1980_GK_CM_105E 投影坐标 2344 Xian_1980_GK_CM_111E 投影坐标 2345 Xian_1980_GK_CM_117E 投影坐标 2346 Xian_1980_GK_CM_123E 投影坐标 2347 Xian_1980_GK_CM_129E 投影坐标 2348 Xian_1980_GK_CM_135E 投影坐标 2349 Xian_1980_3_Degree_GK_Zone_25 投影坐标 2350 Xian_1980_3_Degree_GK_Zone_26 投影坐标 2351 Xian_1980_3_Degree_GK_Zone_27 投影坐标 2352 Xian_1980_3_Degree_GK_Zone_28 投影坐标 2353 Xian_1980_3_Degree_GK_Zone_29 投影坐标 2354 Xian_1980_3_Degree_GK_Zone_30 投影坐标 2355 Xian_1980_3_Degree_GK_Zone_31 投影坐标 2356 Xian_1980_3_Degree_GK_Zone_32 投影坐标 2357 Xian_1980_3_Degree_GK_Zone_33 投影坐标 2358 Xian_1980_3_Degree_GK_Zone_34 投影坐标 2359 Xian_1980_3_Degree_GK_Zone_35 投影坐标 2360 Xian_1980_3_Degree_GK_Zone_36 投影坐标 2361 Xian_1980_3_Degree_GK_Zone_37 投影坐标 2362 Xian_1980_3_Degree_GK_Zone_38 投影坐标 2363 Xian_1980_3_Degree_GK_Zone_39 投影坐标 2364 Xian_1980_3_Degree_GK_Zone_40 投影坐标 2365 Xian_1980_3_Degree_GK_Zone_41 投影坐标 2366 Xian_1980_3_Degree_GK_Zone_42 投影坐标 2367 Xian_1980_3_Degree_GK_Zone_43 投影坐标 2368 Xian_1980_3_Degree_GK_Zone_44 投影坐标 2369 Xian_1980_3_Degree_GK_Zone_45 投影坐标 2370 Xian_1980_3_Degree_GK_CM_75E 投影坐标 2371 Xian_1980_3_Degree_GK_CM_78E 投影坐标 2372 Xian_1980_3_Degree_GK_CM_81E 投影坐标 2373 Xian_1980_3_Degree_GK_CM_84E 投影坐标 2374 Xian_1980_3_Degree_GK_CM_87E 投影坐标 2375 Xian_1980_3_Degree_GK_CM_90E 投影坐标 2376 Xian_1980_3_Degree_GK_CM_93E 投影坐标 2377 Xian_1980_3_Degree_GK_CM_96E 投影坐标 2378 Xian_1980_3_Degree_GK_CM_99E 投影坐标 2379 Xian_1980_3_Degree_GK_CM_102E 投影坐标 2380 Xian_1980_3_Degree_GK_CM_105E 投影坐标 2381 Xian_1980_3_Degree_GK_CM_108E 投影坐标 2382 Xian_1980_3_Degree_GK_CM_111E 投影坐标 2383 Xian_1980_3_Degree_GK_CM_114E 投影坐标 2384 Xian_1980_3_Degree_GK_CM_117E 投影坐标 2385 Xian_1980_3_Degree_GK_CM_120E 投影坐标 2386 Xian_1980_3_Degree_GK_CM_123E 投影坐标 2387 Xian_1980_3_Degree_GK_CM_126E 投影坐标 2388 Xian_1980_3_Degree_GK_CM_129E 投影坐标 2389 Xian_1980_3_Degree_GK_CM_132E 投影坐标 2390 Xian_1980_3_Degree_GK_CM_135E 投影坐标 2401 Beijing_1954_3_Degree_GK_Zone_25 投影坐标 2402 Beijing_1954_3_Degree_GK_Zone_26 投影坐标 2403 Beijing_1954_3_Degree_GK_Zone_27 投影坐标 2404 Beijing_1954_3_Degree_GK_Zone_28 投影坐标 2405 Beijing_1954_3_Degree_GK_Zone_29 投影坐标 2406 Beijing_1954_3_Degree_GK_Zone_30 投影坐标 2407 Beijing_1954_3_Degree_GK_Zone_31 投影坐标 2408 Beijing_1954_3_Degree_GK_Zone_32 投影坐标 2409 Beijing_1954_3_Degree_GK_Zone_33 投影坐标 2410 Beijing_1954_3_Degree_GK_Zone_34 投影坐标 2411 Beijing_1954_3_Degree_GK_Zone_35 投影坐标 2412 Beijing_1954_3_Degree_GK_Zone_36 投影坐标 2413 Beijing_1954_3_Degree_GK_Zone_37 投影坐标 2414 Beijing_1954_3_Degree_GK_Zone_38 投影坐标 2415 Beijing_1954_3_Degree_GK_Zone_39 投影坐标 2416 Beijing_1954_3_Degree_GK_Zone_40 投影坐标 2417 Beijing_1954_3_Degree_GK_Zone_41 投影坐标 2418 Beijing_1954_3_Degree_GK_Zone_42 投影坐标 2419 Beijing_1954_3_Degree_GK_Zone_43 投影坐标 2420 Beijing_1954_3_Degree_GK_Zone_44 投影坐标 2421 Beijing_1954_3_Degree_GK_Zone_45 投影坐标 2422 Beijing_1954_3_Degree_GK_CM_75E 投影坐标 2423 Beijing_1954_3_Degree_GK_CM_78E 投影坐标 2424 Beijing_1954_3_Degree_GK_CM_81E 投影坐标 2425 Beijing_1954_3_Degree_GK_CM_84E 投影坐标 2426 Beijing_1954_3_Degree_GK_CM_87E 投影坐标 2427 Beijing_1954_3_Degree_GK_CM_90E 投影坐标 2428 Beijing_1954_3_Degree_GK_CM_93E 投影坐标 2429 Beijing_1954_3_Degree_GK_CM_96E 投影坐标 2430 Beijing_1954_3_Degree_GK_CM_99E 投影坐标 2431 Beijing_1954_3_Degree_GK_CM_102E 投影坐标 2432 Beijing_1954_3_Degree_GK_CM_105E 投影坐标 2433 Beijing_1954_3_Degree_GK_CM_108E 投影坐标 2434 Beijing_1954_3_Degree_GK_CM_111E 投影坐标 2435 Beijing_1954_3_Degree_GK_CM_114E 投影坐标 2436 Beijing_1954_3_Degree_GK_CM_117E 投影坐标 2437 Beijing_1954_3_Degree_GK_CM_120E 投影坐标 2438 Beijing_1954_3_Degree_GK_CM_123E 投影坐标 2439 Beijing_1954_3_Degree_GK_CM_126E 投影坐标 2440 Beijing_1954_3_Degree_GK_CM_129E 投影坐标 2441 Beijing_1954_3_Degree_GK_CM_132E 投影坐标 2442 Beijing_1954_3_Degree_GK_CM_135E 投影坐标 3395 WGS_1984_World_Mercator 投影坐标 4491 CGCS2000_GK_Zone_13 投影坐标 4492 CGCS2000_GK_Zone_14 投影坐标 4493 CGCS2000_GK_Zone_15 投影坐标 4494 CGCS2000_GK_Zone_16 投影坐标 4495 CGCS2000_GK_Zone_17 投影坐标 4496 CGCS2000_GK_Zone_18 投影坐标 4497 CGCS2000_GK_Zone_19 投影坐标 4498 CGCS2000_GK_Zone_20 投影坐标 4499 CGCS2000_GK_Zone_21 投影坐标 4500 CGCS2000_GK_Zone_22 投影坐标 4501 CGCS2000_GK_Zone_23 投影坐标 4502 CGCS2000_GK_CM_75E 投影坐标 4503 CGCS2000_GK_CM_81E 投影坐标 4504 CGCS2000_GK_CM_87E 投影坐标 4505 CGCS2000_GK_CM_93E 投影坐标 4506 CGCS2000_GK_CM_99E 投影坐标 4507 CGCS2000_GK_CM_105E 投影坐标 4508 CGCS2000_GK_CM_111E 投影坐标 4509 CGCS2000_GK_CM_117E 投影坐标 4510 CGCS2000_GK_CM_123E 投影坐标 4511 CGCS2000_GK_CM_129E 投影坐标 4512 CGCS2000_GK_CM_135E 投影坐标 4513 CGCS2000_3_Degree_GK_Zone_25 投影坐标 4514 CGCS2000_3_Degree_GK_Zone_26 投影坐标 4515 CGCS2000_3_Degree_GK_Zone_27 投影坐标 4516 CGCS2000_3_Degree_GK_Zone_28 投影坐标 4517 CGCS2000_3_Degree_GK_Zone_29 投影坐标 4518 CGCS2000_3_Degree_GK_Zone_30 投影坐标 4519 CGCS2000_3_Degree_GK_Zone_31 投影坐标 4520 CGCS2000_3_Degree_GK_Zone_32 投影坐标 4521 CGCS2000_3_Degree_GK_Zone_33 投影坐标 4522 CGCS2000_3_Degree_GK_Zone_34 投影坐标 4523 CGCS2000_3_Degree_GK_Zone_35 投影坐标 4524 CGCS2000_3_Degree_GK_Zone_36 投影坐标 4525 CGCS2000_3_Degree_GK_Zone_37 投影坐标 4526 CGCS2000_3_Degree_GK_Zone_38 投影坐标 4527 CGCS2000_3_Degree_GK_Zone_39 投影坐标 4528 CGCS2000_3_Degree_GK_Zone_40 投影坐标 4529 CGCS2000_3_Degree_GK_Zone_41 投影坐标 4530 CGCS2000_3_Degree_GK_Zone_42 投影坐标 4531 CGCS2000_3_Degree_GK_Zone_43 投影坐标 4532 CGCS2000_3_Degree_GK_Zone_44 投影坐标 4533 CGCS2000_3_Degree_GK_Zone_45 投影坐标 4534 CGCS2000_3_Degree_GK_CM_75E 投影坐标 4535 CGCS2000_3_Degree_GK_CM_78E 投影坐标 4536 CGCS2000_3_Degree_GK_CM_81E 投影坐标 4537 CGCS2000_3_Degree_GK_CM_84E 投影坐标 4538 CGCS2000_3_Degree_GK_CM_87E 投影坐标 4539 CGCS2000_3_Degree_GK_CM_90E 投影坐标 4540 CGCS2000_3_Degree_GK_CM_93E 投影坐标 4541 CGCS2000_3_Degree_GK_CM_96E 投影坐标 4542 CGCS2000_3_Degree_GK_CM_99E 投影坐标 4543 CGCS2000_3_Degree_GK_CM_102E 投影坐标 4544 CGCS2000_3_Degree_GK_CM_105E 投影坐标 4545 CGCS2000_3_Degree_GK_CM_108E 投影坐标 4546 CGCS2000_3_Degree_GK_CM_111E 投影坐标 4547 CGCS2000_3_Degree_GK_CM_114E 投影坐标 4548 CGCS2000_3_Degree_GK_CM_117E 投影坐标 4549 CGCS2000_3_Degree_GK_CM_120E 投影坐标 4550 CGCS2000_3_Degree_GK_CM_123E 投影坐标 4551 CGCS2000_3_Degree_GK_CM_126E 投影坐标 4552 CGCS2000_3_Degree_GK_CM_129E 投影坐标 4553 CGCS2000_3_Degree_GK_CM_132E 投影坐标 4554 CGCS2000_3_Degree_GK_CM_135E 投影坐标 4568 New_Beijing_Gauss_Kruger_Zone_13 投影坐标 4569 New_Beijing_Gauss_Kruger_Zone_14 投影坐标 4570 New_Beijing_Gauss_Kruger_Zone_15 投影坐标 4571 New_Beijing_Gauss_Kruger_Zone_16 投影坐标 4572 New_Beijing_Gauss_Kruger_Zone_17 投影坐标 4573 New_Beijing_Gauss_Kruger_Zone_18 投影坐标 4574 New_Beijing_Gauss_Kruger_Zone_19 投影坐标 4575 New_Beijing_Gauss_Kruger_Zone_20 投影坐标 4576 New_Beijing_Gauss_Kruger_Zone_21 投影坐标 4577 New_Beijing_Gauss_Kruger_Zone_22 投影坐标 4578 New_Beijing_Gauss_Kruger_Zone_23 投影坐标 4579 New_Beijing_Gauss_Kruger_CM_75E 投影坐标 4580 New_Beijing_Gauss_Kruger_CM_81E 投影坐标 4581 New_Beijing_Gauss_Kruger_CM_87E 投影坐标 4582 New_Beijing_Gauss_Kruger_CM_93E 投影坐标 4583 New_Beijing_Gauss_Kruger_CM_99E 投影坐标 4584 New_Beijing_Gauss_Kruger_CM_105E 投影坐标 4585 New_Beijing_Gauss_Kruger_CM_111E 投影坐标 4586 New_Beijing_Gauss_Kruger_CM_117E 投影坐标 4587 New_Beijing_Gauss_Kruger_CM_123E 投影坐标 4588 New_Beijing_Gauss_Kruger_CM_129E 投影坐标 4589 New_Beijing_Gauss_Kruger_CM_135E 投影坐标 4652 New_Beijing_3_Degree_Gauss_Kruger_Zone_25 投影坐标 4653 New_Beijing_3_Degree_Gauss_Kruger_Zone_26 投影坐标 4654 New_Beijing_3_Degree_Gauss_Kruger_Zone_27 投影坐标 4655 New_Beijing_3_Degree_Gauss_Kruger_Zone_28 投影坐标 4656 New_Beijing_3_Degree_Gauss_Kruger_Zone_29 投影坐标 4766 New_Beijing_3_Degree_Gauss_Kruger_Zone_30 投影坐标 4767 New_Beijing_3_Degree_Gauss_Kruger_Zone_31 投影坐标 4768 New_Beijing_3_Degree_Gauss_Kruger_Zone_32 投影坐标 4769 New_Beijing_3_Degree_Gauss_Kruger_Zone_33 投影坐标 4770 New_Beijing_3_Degree_Gauss_Kruger_Zone_34 投影坐标 4771 New_Beijing_3_Degree_Gauss_Kruger_Zone_35 投影坐标 4772 New_Beijing_3_Degree_Gauss_Kruger_Zone_36 投影坐标 4773 New_Beijing_3_Degree_Gauss_Kruger_Zone_37 投影坐标 4774 New_Beijing_3_Degree_Gauss_Kruger_Zone_38 投影坐标 4775 New_Beijing_3_Degree_Gauss_Kruger_Zone_39 投影坐标 4776 New_Beijing_3_Degree_Gauss_Kruger_Zone_40 投影坐标 4777 New_Beijing_3_Degree_Gauss_Kruger_Zone_41 投影坐标 4778 New_Beijing_3_Degree_Gauss_Kruger_Zone_42 投影坐标 4779 New_Beijing_3_Degree_Gauss_Kruger_Zone_43 投影坐标 4780 New_Beijing_3_Degree_Gauss_Kruger_Zone_44 投影坐标 4781 New_Beijing_3_Degree_Gauss_Kruger_Zone_45 投影坐标 4782 New_Beijing_3_Degree_Gauss_Kruger_CM_75E 投影坐标 4783 New_Beijing_3_Degree_Gauss_Kruger_CM_78E 投影坐标 4784 New_Beijing_3_Degree_Gauss_Kruger_CM_81E 投影坐标 4785 New_Beijing_3_Degree_Gauss_Kruger_CM_84E 投影坐标 4786 New_Beijing_3_Degree_Gauss_Kruger_CM_87E 投影坐标 4787 New_Beijing_3_Degree_Gauss_Kruger_CM_90E 投影坐标 4788 New_Beijing_3_Degree_Gauss_Kruger_CM_93E 投影坐标 4789 New_Beijing_3_Degree_Gauss_Kruger_CM_96E 投影坐标 4790 New_Beijing_3_Degree_Gauss_Kruger_CM_99E 投影坐标 4791 New_Beijing_3_Degree_Gauss_Kruger_CM_102E 投影坐标 4792 New_Beijing_3_Degree_Gauss_Kruger_CM_105E 投影坐标 4793 New_Beijing_3_Degree_Gauss_Kruger_CM_108E 投影坐标 4794 New_Beijing_3_Degree_Gauss_Kruger_CM_111E 投影坐标 4795 New_Beijing_3_Degree_Gauss_Kruger_CM_114E 投影坐标 4796 New_Beijing_3_Degree_Gauss_Kruger_CM_117E 投影坐标 4797 New_Beijing_3_Degree_Gauss_Kruger_CM_120E 投影坐标 4798 New_Beijing_3_Degree_Gauss_Kruger_CM_123E 投影坐标 4799 New_Beijing_3_Degree_Gauss_Kruger_CM_126E 投影坐标 4800 New_Beijing_3_Degree_Gauss_Kruger_CM_129E 投影坐标 4822 New_Beijing_3_Degree_Gauss_Kruger_CM_135E 面积求值在求面中，对wkid为4610的值另外做了处理，使用的是geodesicUtils提供的geodesicAreas方法求面积。 function calArea(polygon, spatialReference) { if (spatialReference.isWebMercator() || spatialReference.wkid == \"4326\" || spatialReference.wkid == \"4490\") { return geometryEngine.geodesicArea(polygon, \"square-meters\") } else if (spatialReference.wkid == \"4610\") { return geodesicUtils.geodesicAreas([polygon], esriUnits.SQUARE_METERS)[0]; } else { return geometryEngine.planarArea(polygon, \"square-meters\") } }","path":"2019/03/13/article2/"},{"title":"我理解的原型链","text":"原型链，开始看资料时觉得还能理解，到后面就有点绕晕了，在看了几篇文章之后，我将关键点剥离出来，进行整理，这样一来，整个原型链就得到了一个很好的理解。那么首先，我们要明确几个概念。 函数（Function）拥有prototype属性，对象（除了null）拥有__proto__ 除了__proto__属性，对象还拥有constructor属性，这个属性使得一个对象指向一个函数，即指向该对象的构造函数，每个对象都具有一个构造函数（本身拥有或继承而来），Function对象的构造函数是它本身，所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function函数。 对象所拥有的__proto__是当访问一个对象当属性时，没有找到该属性，就会去它的__proto__属性所指向的那个对象（父对象）里找，一直寻找，直到__proto__属性的值为null，返回undefined，通过__proto__属性将对象连接起来的这条链路就是原型链。 在js中一切都为对象，正是因为这个，函数也是一个对象，所以函数在作为对象时拥有__proto__和constructor，作为函数时又拥有prototype属性。 根据上面几个概念，我们来做几个测试。 1.函数及其实例化对象之间的关系 var obj=function(){}; // 定义一个函数，此时它既是函数也是对象，所以同时拥有prototype和__proto__属性 console.log(obj.prototype) // => {constructor: ƒ} console.log(obj.__proto__) // => ƒ () { [native code] } var o=new obj(); // 实例化一个o对象 console.log(o.__proto__) // =>{constructor: ƒ} 我理解的就是obj的prototype属性constructor指向obj本身，而其实例化的o的__proto__属性也是指向obj原型，故相等 o.__proto__ === obj.prototype // => true 现在我们知道对象o的__proto__属性的constructor也是ƒ (){}，而obj本身就是一个ƒ (){}，自然相等 o.__proto__.constructor===obj // => true 2.obj与构造函数Function的关系我们知道每个对象都具有一个__proto__属性，而每个构造函数都有一个prototype方法，每个对象的__proto__属性指向自身构造函数的prototype； obj.__proto__===Function.prototype // => true obj.__proto__.constructor===Function // => true 3.Function和ObjectECMAScript规定了两个特殊的内置对象：Object和Function。他们的特殊性在于，他们本身既是对象又是函数，而他们同时也是对象和函数的构造器。 // 构造器Function的构造器是它自身 Function.constructor=== Function // => true // 构造器Object的构造器是Function （所有构造器的constructor都指向Function） Object.constructor === Function // => true // 构造器Function的__proto__是一个特殊的匿名函数function() {} console.log(Function.__proto__) // => function() {} // 这个特殊的匿名函数的__proto__指向Object的prototype原型 Function.__proto__.__proto__ === Object.prototype // => true // Object的__proto__指向Function的prototype，也就是上面所述的特殊匿名函数 Object.__proto__ === Function.prototype // => true Function.__proto__ === Function.prototype // => true 注： 所有的构造器的constructor都指向Function Function的__proto__指向一个匿名函数，而这个匿名函数的__proto__指向Object.prototype instanceofinstanceof运算符用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上 function Person() {} console.log(Object instanceof Object); //true //第一个Object的原型链：Object=> //Object.__proto__ => Function.prototype=>Function.prototype.__proto__=>Object.prototype //第二个Object的原型：Object=> Object.prototype console.log(Function instanceof Function); //true //第一个Function的原型链：Function=>Function.__proto__ => Function.prototype //第二个Function的原型：Function=>Function.prototype console.log(Function instanceof Object); //true //Function=> //Function.__proto__=>Function.prototype=>Function.prototype.__proto__=>Object.prototype //Object => Object.prototype console.log(Person instanceof Function); //true //Person=>Person.__proto__=>Function.prototype //Function=>Function.prototype console.log(String instanceof String); //false //第一个String的原型链：String=> //String.__proto__=>Function.prototype=>Function.prototype.__proto__=>Object.prototype //第二个String的原型链：String=>String.prototype console.log(Boolean instanceof Boolean); //false //第一个Boolean的原型链：Boolean=> //Boolean.__proto__=>Function.prototype=>Function.prototype.__proto__=>Object.prototype //第二个Boolean的原型链：Boolean=>Boolean.prototype console.log(Person instanceof Person); //false //第一个Person的原型链：Person=> //Person.__proto__=>Function.prototype=>Function.prototype.__proto__=>Object.prototype //第二个Person的原型链：Person=>Person.prototype","path":"2018/11/22/article11/"}]}